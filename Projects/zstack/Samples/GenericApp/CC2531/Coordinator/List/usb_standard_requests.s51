///////////////////////////////////////////////////////////////////////////////
//                                                                            /
// IAR C/C++ Compiler V8.10.1.10194/W32 for 8051        22/May/2013  10:02:06 /
// Copyright 2004-2011 IAR Systems AB.                                        /
//                                                                            /
//    Core               =  plain                                             /
//    Code model         =  banked                                            /
//    Data model         =  large                                             /
//    Calling convention =  xdata reentrant                                   /
//    Constant location  =  data_rom                                          /
//    Dptr setup         =  1,16                                              /
//    Source file        =  D:\Texas Instruments\ZIG_TEMCO\Components\hal\tar /
//                          get\CC2530USB\usb\library\usb_standard_requests.c /
//    Command line       =  -f "D:\Texas Instruments\ZIG_TEMCO\Projects\zstac /
//                          k\Samples\GenericApp\CC2531\..\..\..\Tools\CC2530 /
//                          DB\f8wCoord.cfg" (-DCPU32MHZ -DROOT=__near_func   /
//                          -DMAC_CFG_APP_PENDING_QUEUE=TRUE                  /
//                          -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8        /
//                          -DMAC_CFG_RX_MAX=5 -DZDO_COORDINATOR -DRTR_NWK)   /
//                          -f "D:\Texas Instruments\ZIG_TEMCO\Projects\zstac /
//                          k\Samples\GenericApp\CC2531\..\..\..\Tools\CC2530 /
//                          DB\f8wConfig.cfg" (-DZIGBEEPRO -DSECURE=0         /
//                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                 /
//                          -DDEFAULT_CHANLIST=0x00002000                     /
//                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                      /
//                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_M /
//                          ASK=0x007F -DBEACON_REQUEST_DELAY=100             /
//                          -DBEACON_REQ_DELAY_MASK=0x00FF                    /
//                          -DLINK_STATUS_JITTER_MASK=0x007F                  /
//                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_P /
//                          OLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7           /
//                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3   /
//                          -DNWK_MAX_DATA_RETRIES=2                          /
//                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9        /
//                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40          /
//                          -DNWK_MAX_BINDING_ENTRIES=4                       /
//                          -DMAX_BINDING_CLUSTER_IDS=4                       /
//                          "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07, 0x09,     /
//                          0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08,   /
//                          0x0A, 0x0C, 0x0D}" -DMAC_MAX_FRAME_SIZE=116       /
//                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const    /
//                          __code" -DGENERIC=__generic                       /
//                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000       /
//                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)  /
//                          -DREJOIN_POLL_RATE=440 "D:\Texas                  /
//                          Instruments\ZIG_TEMCO\Components\hal\target\CC253 /
//                          0USB\usb\library\usb_standard_requests.c" -D      /
//                          ZTOOL_P1 -D NV_INIT -D NV_RESTORE -D USB_DONGLE   /
//                          -D MODBUS_SUPPLY -D xMT_TASK -D xMT_SYS_FUNC -D   /
//                          xMT_ZDO_FUNC -lC "D:\Texas                        /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\Coordinator\List\" -lA "D:\Texas   /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\Coordinator\List\"                 /
//                          --diag_suppress Pe001,Pa010 -o "D:\Texas          /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\Coordinator\Obj\" -e               /
//                          --no_code_motion --debug --core=plain             /
//                          --dptr=16,1 --data_model=large                    /
//                          --code_model=banked --calling_convention=xdata_re /
//                          entrant --place_constants=data_rom                /
//                          --nr_virtual_regs 16 -I "D:\Texas                 /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\" -I "D:\Texas                     /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\Source\" -I "D:\Texas           /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\ZMain\TI2530DB\" -I       /
//                          "D:\Texas Instruments\ZIG_TEMCO\Projects\zstack\S /
//                          amples\GenericApp\CC2531\..\..\..\..\..\Component /
//                          s\hal\include\" -I "D:\Texas                      /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\hal\targ /
//                          et\CC2530USB\" -I "D:\Texas                       /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\hal\targ /
//                          et\CC2530USB\usb\library\" -I "D:\Texas           /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\hal\targ /
//                          et\CC2530USB\usb\library\cc2531\" -I "D:\Texas    /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\hal\targ /
//                          et\CC2530USB\usb\class_cdc\" -I "D:\Texas         /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\mac\incl /
//                          ude\" -I "D:\Texas Instruments\ZIG_TEMCO\Projects /
//                          \zstack\Samples\GenericApp\CC2531\..\..\..\..\..\ /
//                          Components\mac\high_level\" -I "D:\Texas          /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\mac\low_ /
//                          level\srf04\" -I "D:\Texas                        /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\mac\low_ /
//                          level\srf04\single_chip\" -I "D:\Texas            /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\mt\" -I  /
//                          "D:\Texas Instruments\ZIG_TEMCO\Projects\zstack\S /
//                          amples\GenericApp\CC2531\..\..\..\..\..\Component /
//                          s\osal\include\" -I "D:\Texas                     /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\services /
//                          \saddr\" -I "D:\Texas Instruments\ZIG_TEMCO\Proje /
//                          cts\zstack\Samples\GenericApp\CC2531\..\..\..\..\ /
//                          ..\Components\services\sdata\" -I "D:\Texas       /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\stack\af /
//                          \" -I "D:\Texas Instruments\ZIG_TEMCO\Projects\zs /
//                          tack\Samples\GenericApp\CC2531\..\..\..\..\..\Com /
//                          ponents\stack\nwk\" -I "D:\Texas                  /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\stack\sa /
//                          pi\" -I "D:\Texas Instruments\ZIG_TEMCO\Projects\ /
//                          zstack\Samples\GenericApp\CC2531\..\..\..\..\..\C /
//                          omponents\stack\sec\" -I "D:\Texas                /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\stack\sy /
//                          s\" -I "D:\Texas Instruments\ZIG_TEMCO\Projects\z /
//                          stack\Samples\GenericApp\CC2531\..\..\..\..\..\Co /
//                          mponents\stack\zdo\" -I "D:\Texas                 /
//                          Instruments\ZIG_TEMCO\Projects\zstack\Samples\Gen /
//                          ericApp\CC2531\..\..\..\..\..\Components\zmac\"   /
//                          -I "D:\Texas Instruments\ZIG_TEMCO\Projects\zstac /
//                          k\Samples\GenericApp\CC2531\..\..\..\..\..\Compon /
//                          ents\zmac\f8w\" -Ohz --require_prototypes         /
//    List file          =  D:\Texas Instruments\ZIG_TEMCO\Projects\zstack\Sa /
//                          mples\GenericApp\CC2531\Coordinator\List\usb_stan /
//                          dard_requests.s51                                 /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME usb_standard_requests

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)

        EXTERN ?BANKED_ENTER_XDATA
        EXTERN ?BANKED_LEAVE_XDATA
        EXTERN ?BDISPATCH
        EXTERN ?BRET
        EXTERN ?C_GPTR_LOAD
        EXTERN ?G_EQ
        EXTERN ?S_SHL
        EXTERN ?US_SHR
        EXTERN ?V0
        EXTERN __INIT_XDATA_Z

        FUNCTION ??ChangeFeature?relay,0203H
        FUNCTION ??ConfigureEndpoints?relay,0203H
        PUBLIC ??usbsrClearFeature?relay
        FUNCTION ??usbsrClearFeature?relay,0203H
        PUBLIC ??usbsrGetConfiguration?relay
        FUNCTION ??usbsrGetConfiguration?relay,0203H
        PUBLIC ??usbsrGetDescriptor?relay
        FUNCTION ??usbsrGetDescriptor?relay,0203H
        PUBLIC ??usbsrGetInterface?relay
        FUNCTION ??usbsrGetInterface?relay,0203H
        PUBLIC ??usbsrGetStatus?relay
        FUNCTION ??usbsrGetStatus?relay,0203H
        PUBLIC ??usbsrSetAddress?relay
        FUNCTION ??usbsrSetAddress?relay,0203H
        PUBLIC ??usbsrSetConfiguration?relay
        FUNCTION ??usbsrSetConfiguration?relay,0203H
        PUBLIC ??usbsrSetFeature?relay
        FUNCTION ??usbsrSetFeature?relay,0203H
        PUBLIC ??usbsrSetInterface?relay
        FUNCTION ??usbsrSetInterface?relay,0203H
        FUNCTION ChangeFeature,021203H
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        FUNCTION ConfigureEndpoints,021203H
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        LOCFRAME XSTACK, 18, STACK
        PUBLIC usbsrClearFeature
        FUNCTION usbsrClearFeature,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrGetConfiguration
        FUNCTION usbsrGetConfiguration,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrGetDescriptor
        FUNCTION usbsrGetDescriptor,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME XSTACK, 12, STACK
        PUBLIC usbsrGetInterface
        FUNCTION usbsrGetInterface,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC usbsrGetStatus
        FUNCTION usbsrGetStatus,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        PUBLIC usbsrSetAddress
        FUNCTION usbsrSetAddress,0203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrSetConfiguration
        FUNCTION usbsrSetConfiguration,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        PUBLIC usbsrSetFeature
        FUNCTION usbsrSetFeature,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 2, STACK
        PUBLIC usbsrSetInterface
        FUNCTION usbsrSetInterface,021203H
        ARGFRAME XSTACK, 0, STACK
        LOCFRAME ISTACK, 1, STACK
        LOCFRAME XSTACK, 10, STACK
        
        CFI Names cfiNames0
        CFI StackFrame CFA_SP SP IDATA
        CFI StackFrame CFA_PSP16 PSP16 XDATA
        CFI StackFrame CFA_XSP16 XSP16 XDATA
        CFI StaticOverlayFrame CFA_IOVERLAY IOVERLAY
        CFI StaticOverlayFrame CFA_DOVERLAY DOVERLAY
        CFI Resource `PSW.CY`:1, `B.BR0`:1, `B.BR1`:1, `B.BR2`:1, `B.BR3`:1
        CFI Resource `B.BR4`:1, `B.BR5`:1, `B.BR6`:1, `B.BR7`:1, `VB.BR8`:1
        CFI Resource `VB.BR9`:1, `VB.BR10`:1, `VB.BR11`:1, `VB.BR12`:1
        CFI Resource `VB.BR13`:1, `VB.BR14`:1, `VB.BR15`:1, VB:8, B:8, A:8
        CFI Resource PSW:8, DPL0:8, DPH0:8, R0:8, R1:8, R2:8, R3:8, R4:8, R5:8
        CFI Resource R6:8, R7:8, V0:8, V1:8, V2:8, V3:8, V4:8, V5:8, V6:8, V7:8
        CFI Resource V8:8, V9:8, V10:8, V11:8, V12:8, V13:8, V14:8, V15:8, SP:8
        CFI Resource PSPH:8, PSPL:8, PSP16:16, XSPH:8, XSPL:8, XSP16:16
        CFI VirtualResource ?RET:24
        CFI Resource ?BRET_EXT:8
        CFI VirtualResource ?RET_HIGH:8, ?RET_LOW:8
        CFI ResourceParts PSP16 PSPH, PSPL
        CFI ResourceParts XSP16 XSPH, XSPL
        CFI ResourceParts ?RET ?BRET_EXT, ?RET_HIGH, ?RET_LOW
        CFI EndNames cfiNames0
        
        CFI Common cfiCommon0 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-3
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B Undefined
        CFI A Undefined
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 Undefined
        CFI R1 Undefined
        CFI R2 Undefined
        CFI R3 Undefined
        CFI R4 Undefined
        CFI R5 Undefined
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT Frame(CFA_SP, 3)
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon0
        
        
        CFI Common cfiCommon1 Using cfiNames0
        CFI CodeAlign 1
        CFI DataAlign -1
        CFI ReturnAddress ?RET CODE
        CFI CFA_DOVERLAY Used
        CFI CFA_IOVERLAY Used
        CFI CFA_SP SP+-2
        CFI CFA_PSP16 PSP16+0
        CFI CFA_XSP16 XSP16+0
        CFI `PSW.CY` SameValue
        CFI `B.BR0` SameValue
        CFI `B.BR1` SameValue
        CFI `B.BR2` SameValue
        CFI `B.BR3` SameValue
        CFI `B.BR4` SameValue
        CFI `B.BR5` SameValue
        CFI `B.BR6` SameValue
        CFI `B.BR7` SameValue
        CFI `VB.BR8` SameValue
        CFI `VB.BR9` SameValue
        CFI `VB.BR10` SameValue
        CFI `VB.BR11` SameValue
        CFI `VB.BR12` SameValue
        CFI `VB.BR13` SameValue
        CFI `VB.BR14` SameValue
        CFI `VB.BR15` SameValue
        CFI VB SameValue
        CFI B SameValue
        CFI A SameValue
        CFI PSW SameValue
        CFI DPL0 SameValue
        CFI DPH0 SameValue
        CFI R0 SameValue
        CFI R1 SameValue
        CFI R2 SameValue
        CFI R3 SameValue
        CFI R4 SameValue
        CFI R5 SameValue
        CFI R6 SameValue
        CFI R7 SameValue
        CFI V0 SameValue
        CFI V1 SameValue
        CFI V2 SameValue
        CFI V3 SameValue
        CFI V4 SameValue
        CFI V5 SameValue
        CFI V6 SameValue
        CFI V7 SameValue
        CFI V8 SameValue
        CFI V9 SameValue
        CFI V10 SameValue
        CFI V11 SameValue
        CFI V12 SameValue
        CFI V13 SameValue
        CFI V14 SameValue
        CFI V15 SameValue
        CFI PSPH Undefined
        CFI PSPL Undefined
        CFI XSPH Undefined
        CFI XSPL Undefined
        CFI ?RET Concat
        CFI ?BRET_EXT SameValue
        CFI ?RET_HIGH Frame(CFA_SP, 2)
        CFI ?RET_LOW Frame(CFA_SP, 1)
        CFI EndCommon cfiCommon1
        
usbsrHookProcessEvent SYMBOL "usbsrHookProcessEvent"
usbsrHookClearFeature SYMBOL "usbsrHookClearFeature"
usbsrHookSetFeature SYMBOL "usbsrHookSetFeature"
usbdpGetDeviceDesc  SYMBOL "usbdpGetDeviceDesc"
usbdpGetConfigurationDesc SYMBOL "usbdpGetConfigurationDesc"
usbdpGetStringDesc  SYMBOL "usbdpGetStringDesc"
usbdpFindNext       SYMBOL "usbdpFindNext"
usbfwSetAllEpStatus SYMBOL "usbfwSetAllEpStatus"
usbdpGetInterfaceDesc SYMBOL "usbdpGetInterfaceDesc"
??usbdpFindNext?relay SYMBOL "?relay", usbdpFindNext
??usbdpGetConfigurationDesc?relay SYMBOL "?relay", usbdpGetConfigurationDesc
??usbdpGetDeviceDesc?relay SYMBOL "?relay", usbdpGetDeviceDesc
??usbdpGetInterfaceDesc?relay SYMBOL "?relay", usbdpGetInterfaceDesc
??usbdpGetStringDesc?relay SYMBOL "?relay", usbdpGetStringDesc
??usbfwSetAllEpStatus?relay SYMBOL "?relay", usbfwSetAllEpStatus
??usbsrHookClearFeature?relay SYMBOL "?relay", usbsrHookClearFeature
??usbsrHookProcessEvent?relay SYMBOL "?relay", usbsrHookProcessEvent
??usbsrHookSetFeature?relay SYMBOL "?relay", usbsrHookSetFeature
usbsrClearFeature   SYMBOL "usbsrClearFeature"
??usbsrClearFeature?relay SYMBOL "?relay", usbsrClearFeature
usbsrGetConfiguration SYMBOL "usbsrGetConfiguration"
??usbsrGetConfiguration?relay SYMBOL "?relay", usbsrGetConfiguration
usbsrGetDescriptor  SYMBOL "usbsrGetDescriptor"
??usbsrGetDescriptor?relay SYMBOL "?relay", usbsrGetDescriptor
usbsrGetInterface   SYMBOL "usbsrGetInterface"
??usbsrGetInterface?relay SYMBOL "?relay", usbsrGetInterface
usbsrGetStatus      SYMBOL "usbsrGetStatus"
??usbsrGetStatus?relay SYMBOL "?relay", usbsrGetStatus
usbsrSetAddress     SYMBOL "usbsrSetAddress"
??usbsrSetAddress?relay SYMBOL "?relay", usbsrSetAddress
usbsrSetConfiguration SYMBOL "usbsrSetConfiguration"
??usbsrSetConfiguration?relay SYMBOL "?relay", usbsrSetConfiguration
usbsrSetFeature     SYMBOL "usbsrSetFeature"
??usbsrSetFeature?relay SYMBOL "?relay", usbsrSetFeature
usbsrSetInterface   SYMBOL "usbsrSetInterface"
??usbsrSetInterface?relay SYMBOL "?relay", usbsrSetInterface

        EXTERN usbsrHookProcessEvent
        FUNCTION usbsrHookProcessEvent,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookClearFeature
        FUNCTION usbsrHookClearFeature,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbsrHookSetFeature
        FUNCTION usbsrHookSetFeature,0202H
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbdpGetDeviceDesc
        FUNCTION usbdpGetDeviceDesc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbdpGetConfigurationDesc
        FUNCTION usbdpGetConfigurationDesc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbdpGetStringDesc
        FUNCTION usbdpGetStringDesc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbdpFindNext
        FUNCTION usbdpFindNext,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbfwSetAllEpStatus
        FUNCTION usbfwSetAllEpStatus,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN usbdpGetInterfaceDesc
        FUNCTION usbdpGetInterfaceDesc,0202H
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        EXTERN ??usbdpFindNext?relay
        FUNCTION ??usbdpFindNext?relay,00H
        EXTERN ??usbdpGetConfigurationDesc?relay
        FUNCTION ??usbdpGetConfigurationDesc?relay,00H
        EXTERN ??usbdpGetDeviceDesc?relay
        FUNCTION ??usbdpGetDeviceDesc?relay,00H
        EXTERN ??usbdpGetInterfaceDesc?relay
        FUNCTION ??usbdpGetInterfaceDesc?relay,00H
        EXTERN ??usbdpGetStringDesc?relay
        FUNCTION ??usbdpGetStringDesc?relay,00H
        EXTERN ??usbfwSetAllEpStatus?relay
        FUNCTION ??usbfwSetAllEpStatus?relay,00H
        EXTERN ??usbsrHookClearFeature?relay
        FUNCTION ??usbsrHookClearFeature?relay,00H
        EXTERN ??usbsrHookProcessEvent?relay
        FUNCTION ??usbsrHookProcessEvent?relay,00H
        EXTERN ??usbsrHookSetFeature?relay
        FUNCTION ??usbsrHookSetFeature?relay,00H
        EXTERN usbDescriptorMarker
        EXTERN usbSetupData
        EXTERN usbSetupHeader
        EXTERN usbfwData

// D:\Texas Instruments\ZIG_TEMCO\Components\hal\target\CC2530USB\usb\library\usb_standard_requests.c
//    1 /***********************************************************************************
//    2 
//    3     Filename:     usb_standard_request.c
//    4 
//    5     Description:  Handle USB standard requests.
//    6 
//    7 ***********************************************************************************/
//    8 
//    9 /// \addtogroup module_usb_standard_requests
//   10 /// @{
//   11 #include "usb_firmware_library_headers.h"
//   12 #include "hal_types.h"
//   13 #include "hal_board.h"
//   14 
//   15 
//   16 
//   17 /** \brief Processes the \ref GET_STATUS request (returns status for the specified recipient)
//   18  *
//   19  * The recipient bits in \ref USB_SETUP_HEADER.requestType specify the desired recipient. This is either the
//   20  * (one and only) device, a specific interface, or a specific endpoint. Some of the status bits can be
//   21  * changed with the SET_FEATURE and CLEAR_FEATURE requests.
//   22  *
//   23  * <b>Parameters</b>:
//   24  * - VALUE: Always 0
//   25  * - INDEX: Depends upon the recipient:
//   26  *     - DEVICE: Always 0
//   27  *     - INTERFACE: Interface number
//   28  *     - ENDPOINT: Endpoint address
//   29  * - LENGTH: Always 2
//   30  *
//   31  * <b>Data (IN)</b>:
//   32  * Depends upon the recipient (the bit field illustrations are MSB first, LSB last):
//   33  * - DEVICE: <tt>00000000.000000RS</tt>, where R(1) = DEVICE_REMOTE_WAKEUP and S(0) = SELF_POWERED
//   34  * - INTERFACE: <tt>00000000.00000000</tt> (all bits are reserved)
//   35  * - ENDPOINT: <tt>00000000.0000000H</tt>, where H(0) = ENDPOINT_HALT
//   36  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//   37 void usbsrGetStatus(void)
usbsrGetStatus:
        CFI Block cfiBlock0 Using cfiCommon0
        CFI Function usbsrGetStatus
        CODE
//   38 {
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//   39    uint8 endpoint;
//   40    static uint16 __xdata status;
//   41 
//   42    // Common sanity check
//   43    if (usbSetupHeader.value || HI_UINT16(usbSetupHeader.index) || (usbSetupHeader.length != 2)) {
        LCALL   ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_36:
        JNZ     ??usbsrGetStatus_0
        INC     DPTR
        INC     DPTR
        MOVX    A,@DPTR
        JNZ     ??usbsrGetStatus_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??usbsrGetStatus_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetStatus_1:
        JZ      ??usbsrGetStatus_2
//   44       usbfwData.ep0Status = EP_STALL;
??usbsrGetStatus_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        LJMP    ??CrossCallReturnLabel_24 & 0xFFFF
//   45 
//   46    // Return status for device, interface, or endpoint
//   47    } else {
//   48       switch (usbSetupHeader.requestType) {
??usbsrGetStatus_2:
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ADD     A,#-0x80
        JZ      ??usbsrGetStatus_3
        DEC     A
        JZ      ??usbsrGetStatus_4
        DEC     A
        JZ      ??usbsrGetStatus_5
        SJMP    ??usbsrGetStatus_0
//   49 
//   50          // Device status:
//   51          //     Bit 0: Self powered
//   52          //     Bit 1: Remote wake-up allowed
//   53       case RT_IN_DEVICE:
//   54 
//   55          // Sanity check
//   56          if (LO_UINT16(usbSetupHeader.index)) {
??usbsrGetStatus_3:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        JNZ     ??usbsrGetStatus_0
//   57             usbfwData.ep0Status = EP_STALL;
//   58 
//   59          // Get the bit values from the USBFW_DATA struct
//   60          } else {
//   61 
//   62             // Self powered?
//   63             status = usbfwData.selfPowered ? 0x0001 : 0x0000;
        MOV     DPTR,#usbfwData + 19
        MOVX    A,@DPTR
        JZ      ??usbsrGetStatus_6
        MOV     R0,#0x1
        SJMP    ??usbsrGetStatus_7
??usbsrGetStatus_6:
        MOV     R0,#0x0
??usbsrGetStatus_7:
        MOV     DPTR,#??status
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//   64 
//   65             // Remote wakeup?
//   66             if (usbfwData.remoteWakeup) status |= 0x0002;
        MOV     DPTR,#usbfwData + 18
        MOVX    A,@DPTR
        JZ      ??usbsrGetStatus_8
        MOV     DPTR,#??status
        MOVX    A,@DPTR
        ORL     A,#0x2
        SJMP    ??usbsrGetStatus_9
//   67          }
//   68          break;
//   69 
//   70          // Interface status:
//   71          //     All bits are reserved
//   72       case RT_IN_INTERFACE:
//   73 
//   74          // Sanity check
//   75          if (usbfwData.usbState != DEV_CONFIGURED) {
??usbsrGetStatus_4:
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetStatus_0
//   76             usbfwData.ep0Status = EP_STALL;
//   77          } else {
//   78             status = 0x0000;
        MOV     DPTR,#??status
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        SJMP    ??usbsrGetStatus_10
//   79          }
//   80          break;
//   81 
//   82          // Endpoint status:
//   83          //     Bit 0: Endpoint halted
//   84       case RT_IN_ENDPOINT:
//   85          endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
??usbsrGetStatus_5:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x7f
        MOV     ?V0 + 0,A
//   86 
//   87          // Sanity check
//   88          if ((usbfwData.usbState != DEV_CONFIGURED) || (endpoint > 5)) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetStatus_0
        MOV     A,?V0 + 0
        CLR     C
        SUBB    A,#0x6
        JNC     ??usbsrGetStatus_0
//   89             usbfwData.ep0Status = EP_STALL;
//   90 
//   91          // Translate endpoint address to status index and return the status
//   92          } else {
//   93 
//   94             // IN
//   95             if (LO_UINT16(usbSetupHeader.index) & 0x80) {
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x80
        JZ      ??usbsrGetStatus_11
//   96                status = (usbfwData.pEpInStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
        LCALL   ?Subroutine10 & 0xFFFF
//   97 
//   98             // OUT
//   99             } else {
??CrossCallReturnLabel_14:
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrGetStatus_12
??usbsrGetStatus_13:
        MOV     R0,#0x1
        SJMP    ??usbsrGetStatus_14
//  100                status = (usbfwData.pEpOutStatus[endpoint - 1] == EP_HALT) ? 0x0001 : 0x0000;
??usbsrGetStatus_11:
        LCALL   ?Subroutine11 & 0xFFFF
//  101             }
//  102          }
//  103          break;
//  104 
//  105       default:
//  106          usbfwData.ep0Status = EP_STALL;
//  107          break;
//  108       }
??CrossCallReturnLabel_16:
        MOVX    A,@DPTR
        XRL     A,#0x3
        JZ      ??usbsrGetStatus_13
??usbsrGetStatus_12:
        MOV     R0,#0x0
??usbsrGetStatus_14:
        MOV     DPTR,#??status
        MOV     A,R0
??usbsrGetStatus_9:
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
??usbsrGetStatus_10:
        MOVX    @DPTR,A
//  109 
//  110       if (usbfwData.ep0Status != EP_STALL) {
??usbsrGetStatus_8:
        MOV     DPTR,#usbfwData + 7
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??usbsrGetStatus_15
//  111          // Send it
//  112          usbSetupData.pBuffer = (uint8 __generic *)&status;
        MOV     DPTR,#usbSetupData
        MOV     A,#??status & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#(??status >> 8) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
//  113          usbSetupData.bytesLeft = 2;
        INC     DPTR
        MOV     A,#0x2
        LCALL   ?Subroutine15 & 0xFFFF
//  114          usbfwData.ep0Status = EP_TX;
//  115       }
//  116    }
??CrossCallReturnLabel_24:
        MOVX    @DPTR,A
        CFI EndBlock cfiBlock0
//  117 } // usbsrGetStatus
??usbsrGetStatus_15:
        REQUIRE ?Subroutine0
        ; // Fall through to label ?Subroutine0

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine0:
        CFI Block cfiBlock1 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x2
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock1

        RSEG XDATA_Z:XDATA:NOROOT(0)
        DATA16
??status:
        DS 2
        REQUIRE __INIT_XDATA_Z
//  118 
//  119 
//  120 
//  121 
//  122 /** \brief Internal function used for the very similar \ref SET_FEATURE and \ref CLEAR_FEATURE requests
//  123  *
//  124  * This function either sets or clears the specified feature on the specified recipient.
//  125  *
//  126  * \param[in]       set
//  127  *     When TRUE, the feature is set. When FALSE, the feature is cleared.
//  128  *
//  129  * \return
//  130  *     TRUE if the selected feature is supported by the USB library. FALSE to indicate that
//  131  *     \ref usbsrHookClearFeature() or \ref usbsrHookSetFeature() must be called.
//  132  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  133 static uint8 ChangeFeature(uint8 set)
ChangeFeature:
        CFI Block cfiBlock2 Using cfiCommon0
        CFI Function ChangeFeature
        CODE
//  134 {
        FUNCALL ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL ChangeFeature, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
        MOV     A,R1
        MOV     R6,A
//  135    uint8 endpoint;
//  136 
//  137    // Sanity check
//  138    if (usbSetupHeader.length || (usbfwData.usbState != DEV_CONFIGURED) && (usbSetupHeader.index != 0)) {
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_28:
        JNZ     ??ChangeFeature_0
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??ChangeFeature_1
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_29:
        JZ      ??ChangeFeature_1
//  139       usbfwData.ep0Status = EP_STALL;
??ChangeFeature_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        LJMP    ??ChangeFeature_2 & 0xFFFF
//  140 
//  141       // Handle based on recipient
//  142    } else {
//  143       switch (usbSetupHeader.requestType & RT_MASK_RECIP) {
??ChangeFeature_1:
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        ANL     A,#0x1f
        JZ      ??ChangeFeature_3
        DEC     A
        JZ      ??ChangeFeature_4
        DEC     A
        JZ      ??ChangeFeature_5
        SJMP    ??ChangeFeature_0
//  144 
//  145       // Device
//  146       case RT_RECIP_DEV:
//  147 
//  148          // Sanity check
//  149          if (LO_UINT16(usbSetupHeader.value) != DEVICE_REMOTE_WAKEUP) {
??ChangeFeature_3:
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        XRL     A,#0x1
        JZ      ??ChangeFeature_6
//  150             return FALSE;
??ChangeFeature_4:
        MOV     R1,#0x0
        LJMP    ??ChangeFeature_7 & 0xFFFF
//  151          } else {
//  152             usbfwData.remoteWakeup = set;
??ChangeFeature_6:
        MOV     A,R6
        MOV     DPTR,#usbfwData + 18
        MOVX    @DPTR,A
//  153             usbsrHookProcessEvent(set ? USBSR_EVENT_REMOTE_WAKEUP_ENABLED : USBSR_EVENT_REMOTE_WAKEUP_DISABLED, 0);
        JZ      ??ChangeFeature_8
        MOV     R1,#0x5
        SJMP    ??ChangeFeature_9
??ChangeFeature_8:
        MOV     R1,#0x6
??ChangeFeature_9:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        LCALL   ??usbsrHookProcessEvent?relay
//  154          }
//  155          break;
        SJMP    ??ChangeFeature_10
//  156 
//  157       // Endpoint
//  158       case RT_RECIP_IF:
//  159          return FALSE;
//  160 
//  161       // Endpoint
//  162       case RT_RECIP_EP:
//  163          endpoint = LO_UINT16(usbSetupHeader.index) & 0x7F;
??ChangeFeature_5:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x7f
        MOV     R2,A
//  164 
//  165          // Sanity check
//  166          if (LO_UINT16(usbSetupHeader.value) != ENDPOINT_HALT) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        JNZ     ??ChangeFeature_4
//  167             return FALSE;
//  168          } else if (endpoint > 5) {
        MOV     A,R2
        CLR     C
        SUBB    A,#0x6
        JNC     ??ChangeFeature_0
//  169             usbfwData.ep0Status = EP_STALL;
//  170          } else {
//  171             USBFW_SELECT_ENDPOINT(endpoint);
        MOV     A,R2
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
//  172 
//  173             // IN
//  174             if (LO_UINT16(usbSetupHeader.index) & 0x80) {
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ANL     A,#0x80
        JZ      ??ChangeFeature_11
//  175                USBCSIL = set ? USBCSIL_SEND_STALL : USBCSIL_CLR_DATA_TOG;
        MOV     A,R6
        JZ      ??ChangeFeature_12
        MOV     A,#0x10
        SJMP    ??ChangeFeature_13
??ChangeFeature_12:
        MOV     A,#0x40
??ChangeFeature_13:
        MOV     DPTR,#0x6211
        MOVX    @DPTR,A
//  176                usbfwData.pEpInStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
        MOV     A,R6
        JZ      ??ChangeFeature_14
        MOV     A,#0x3
        SJMP    ??ChangeFeature_15
??ChangeFeature_14:
        CLR     A
??ChangeFeature_15:
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     ?V0 + 0,R2
        LCALL   ?Subroutine10 & 0xFFFF
??CrossCallReturnLabel_15:
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  177                usbsrHookProcessEvent(set ? USBSR_EVENT_EPIN_STALL_SET : USBSR_EVENT_EPIN_STALL_CLEARED, endpoint);
        MOV     A,R6
        JZ      ??ChangeFeature_16
        MOV     R1,#0x8
        SJMP    ??ChangeFeature_17
??ChangeFeature_16:
        MOV     R1,#0x7
        ; Setup parameters for call to function usbsrHookProcessEvent
        SJMP    ??ChangeFeature_17
//  178 
//  179             // OUT
//  180             } else {
//  181                USBCSOL = set ? USBCSOL_SEND_STALL : USBCSOL_CLR_DATA_TOG;
??ChangeFeature_11:
        MOV     A,R6
        JZ      ??ChangeFeature_18
        MOV     A,#0x20
        SJMP    ??ChangeFeature_19
??ChangeFeature_18:
        MOV     A,#-0x80
??ChangeFeature_19:
        MOV     DPTR,#0x6214
        MOVX    @DPTR,A
//  182                usbfwData.pEpOutStatus[endpoint - 1] = set ? EP_HALT : EP_IDLE;
        MOV     A,R6
        JZ      ??ChangeFeature_20
        MOV     A,#0x3
        SJMP    ??ChangeFeature_21
??ChangeFeature_20:
        CLR     A
??ChangeFeature_21:
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     ?V0 + 0,R2
        LCALL   ?Subroutine11 & 0xFFFF
??CrossCallReturnLabel_17:
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  183                usbsrHookProcessEvent(set ? USBSR_EVENT_EPOUT_STALL_SET : USBSR_EVENT_EPOUT_STALL_CLEARED, endpoint);
        MOV     A,R6
        JZ      ??ChangeFeature_22
        MOV     R1,#0xa
        SJMP    ??ChangeFeature_17
??ChangeFeature_22:
        MOV     R1,#0x9
??ChangeFeature_17:
        ; Setup parameters for call to function usbsrHookProcessEvent
        LCALL   ??usbsrHookProcessEvent?relay
//  184             }
//  185             USBFW_SELECT_ENDPOINT(0);
        MOV     DPTR,#0x620e
        CLR     A
??ChangeFeature_2:
        MOVX    @DPTR,A
//  186          }
//  187          break;
//  188 
//  189       default:
//  190          usbfwData.ep0Status = EP_STALL;
//  191          break;
//  192       }
//  193    }
//  194    return TRUE;
??ChangeFeature_10:
        MOV     R1,#0x1
??ChangeFeature_7:
        LJMP    ?Subroutine0 & 0xFFFF
        CFI EndBlock cfiBlock2
//  195 } // ChangeFeature

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine11:
        CFI Block cfiCond3 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_16
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond4 Using cfiCommon0
        CFI (cfiCond4) NoFunction
        CFI (cfiCond4) Conditional ??CrossCallReturnLabel_17
        CFI (cfiCond4) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond4) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond4) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond4) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond4) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond4) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond4) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond4) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond4) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond4) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond4) CFA_SP SP+-1
        CFI (cfiCond4) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiPicker5 Using cfiCommon1
        CFI (cfiPicker5) NoFunction
        CFI (cfiPicker5) Picker
        MOV     A,#(usbfwData + 12) & 0xff
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,#((usbfwData + 12) >> 8) & 0xff
        ADDC    A,#0x0
        MOV     DPH,A
        RET
        CFI EndBlock cfiCond3
        CFI EndBlock cfiCond4
        CFI EndBlock cfiPicker5

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine10:
        CFI Block cfiCond6 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_14
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond7 Using cfiCommon0
        CFI (cfiCond7) NoFunction
        CFI (cfiCond7) Conditional ??CrossCallReturnLabel_15
        CFI (cfiCond7) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond7) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond7) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond7) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond7) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond7) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond7) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond7) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond7) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond7) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond7) CFA_SP SP+-1
        CFI (cfiCond7) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiPicker8 Using cfiCommon1
        CFI (cfiPicker8) NoFunction
        CFI (cfiPicker8) Picker
        MOV     A,#(usbfwData + 7) & 0xff
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,#((usbfwData + 7) >> 8) & 0xff
        ADDC    A,#0x0
        MOV     DPH,A
        RET
        CFI EndBlock cfiCond6
        CFI EndBlock cfiCond7
        CFI EndBlock cfiPicker8
//  196 
//  197 
//  198 
//  199 
//  200 /** \brief Processes the \ref CLEAR_FEATURE request (clears or disables a specific feature)
//  201  *
//  202  * The feature selector value must be appropriate to the recipient.
//  203  *
//  204  * <b>Parameters</b>:
//  205  * - VALUE: Feature selector:
//  206  *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
//  207  *     - \c ENDPOINT_HALT(0): Clear the halt feature for the specified endpoint (not endpoint 0!)
//  208  * - INDEX: Depends upon the recipient:
//  209  *     - DEVICE: Always 0
//  210  *     - INTERFACE: Interface number
//  211  *     - ENDPOINT: Endpoint address
//  212  * - LENGTH: Always 0
//  213  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  214 void usbsrClearFeature()
usbsrClearFeature:
        CFI Block cfiBlock9 Using cfiCommon0
        CFI Function usbsrClearFeature
        CODE
//  215 {
        FUNCALL usbsrClearFeature, ChangeFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrClearFeature, usbsrHookClearFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  216    if (!ChangeFeature(FALSE)) {
        ; Setup parameters for call to function ChangeFeature
        MOV     R1,#0x0
        LCALL   ??ChangeFeature?relay
        MOV     A,R1
        JNZ     ??usbsrClearFeature_0
//  217       usbsrHookClearFeature();
        ; Setup parameters for call to function usbsrHookClearFeature
        LCALL   ??usbsrHookClearFeature?relay
//  218    }
//  219 } // usbsrClearFeature
??usbsrClearFeature_0:
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock9
//  220 
//  221 
//  222 
//  223 
//  224 /** \brief Processes the \ref SET_FEATURE request (sets or enables a specific feature)
//  225  *
//  226  * The feature selector value must be appropriate to the recipient.
//  227  *
//  228  * <b>Parameters</b>:
//  229  * - VALUE: Feature selector:
//  230  *     - \c DEVICE_REMOTE_WAKEUP(1): Enable remote wakeup
//  231  *     - \c ENDPOINT_HALT(0): Set the halt feature for the specified endpoint (not endpoint 0!)
//  232  * - INDEX: Depends upon the recipient:
//  233  *     - DEVICE: Always 0
//  234  *     - INTERFACE: Interface number
//  235  *     - ENDPOINT: Endpoint address
//  236  * - LENGTH: Always 0
//  237  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  238 void usbsrSetFeature(void)
usbsrSetFeature:
        CFI Block cfiBlock10 Using cfiCommon0
        CFI Function usbsrSetFeature
        CODE
//  239 {
        FUNCALL usbsrSetFeature, ChangeFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetFeature, usbsrHookSetFeature
        LOCFRAME ISTACK, 2, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 0, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 2, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 0, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  240    if (!ChangeFeature(TRUE)) {
        ; Setup parameters for call to function ChangeFeature
        MOV     R1,#0x1
        LCALL   ??ChangeFeature?relay
        MOV     A,R1
        JNZ     ??usbsrSetFeature_0
//  241       usbsrHookSetFeature();
        ; Setup parameters for call to function usbsrHookSetFeature
        LCALL   ??usbsrHookSetFeature?relay
//  242    }
//  243 } // usbsrSetFeature
??usbsrSetFeature_0:
        SJMP    ?Subroutine1
        CFI EndBlock cfiBlock10
//  244 
//  245 
//  246 
//  247 
//  248 /** \brief Processes the \ref SET_ADDRESS request (sets the device address for all future device
//  249  * accesses)
//  250  *
//  251  * If the value is between 1 and 127 and the device is in the default state, it will enter the address
//  252  * state. If it already is in the address state, it starts to use the newly-specified address.
//  253  *
//  254  * If the value is 0 and the device is in the address state, it will enter the default state. If it
//  255  * already is in the default state, nothing happens.
//  256  *
//  257  * <b>Parameters</b>:
//  258  * - VALUE: The device address (0-127)
//  259  * - INDEX: Always 0
//  260  * - LENGTH: Always 0
//  261  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  262 void usbsrSetAddress(void)
usbsrSetAddress:
        CFI Block cfiBlock11 Using cfiCommon0
        CFI Function usbsrSetAddress
        CODE
//  263 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  264 
//  265    // Sanity check
//  266    if (usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value) || (LO_UINT16(usbSetupHeader.value) & 0x80)) {
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_30:
        JNZ     ??usbsrSetAddress_0
        INC     DPTR
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_31:
        JNZ     ??usbsrSetAddress_0
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        ANL     A,#0x80
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        JZ      ??usbsrSetAddress_1
//  267       usbfwData.ep0Status = EP_STALL;
??usbsrSetAddress_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??usbsrSetAddress_2
//  268 
//  269    // Update the device address
//  270    } else {
//  271       USBADDR = LO_UINT16(usbSetupHeader.value);
??usbsrSetAddress_1:
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     DPTR,#0x6200
        MOVX    @DPTR,A
//  272       if (LO_UINT16(usbSetupHeader.value) != 0) {
        MOV     DPTR,#usbfwData
        JZ      ??usbsrSetAddress_3
//  273          if (usbfwData.usbState == DEV_DEFAULT) usbfwData.usbState = DEV_ADDRESS;
        MOVX    A,@DPTR
        XRL     A,#0x2
        JNZ     ??usbsrSetAddress_4
        MOV     A,#0x3
        SJMP    ??usbsrSetAddress_2
//  274       } else {
//  275          if (usbfwData.usbState == DEV_ADDRESS) usbfwData.usbState = DEV_DEFAULT;
??usbsrSetAddress_3:
        MOVX    A,@DPTR
        XRL     A,#0x3
        JNZ     ??usbsrSetAddress_4
        MOV     A,#0x2
??usbsrSetAddress_2:
        MOVX    @DPTR,A
        CFI EndBlock cfiBlock11
//  276       }
//  277    }
//  278 
//  279 } // usbsrSetAddress
??usbsrSetAddress_4:
        REQUIRE ?Subroutine1
        ; // Fall through to label ?Subroutine1

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine1:
        CFI Block cfiBlock12 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+-5
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        POP     DPH
        CFI CFA_SP SP+-4
        CFI DPH0 SameValue
        POP     DPL
        CFI CFA_SP SP+-3
        CFI DPL0 SameValue
        LJMP    ?BRET
        CFI EndBlock cfiBlock12
//  280 
//  281 
//  282 
//  283 
//  284 /** \brief Processes the \ref GET_DESCRIPTOR request (returns the specified USB descriptor)
//  285  *
//  286  * The \ref module_usb_descriptor_parser module is used to locate device, configuration and string
//  287  * descriptors. Note that configuration descriptors also include interface, endpoint and other
//  288  * "similar" descriptor types (e.g. HID descriptor), with the total descriptor length specified by
//  289  * the \ref USB_CONFIGURATION_DESCRIPTOR.wTotalLength field.
//  290  *
//  291  * Other descriptor types that are not returned with the configuration descriptor, must be defined in
//  292  * the usbDescriptorMarker.pUsbDescLut lookup-table. This table specifies the values of the VALUE and INDEX fields, and
//  293  * gives a pointer to the descriptor along with it's length.
//  294  *
//  295  * <b>Parameters</b>:
//  296  * - VALUE.MSB: Descriptor type
//  297  * - VALUE.LSB: Descriptor index
//  298  * - INDEX: 0, or language ID for string descriptors (currently not supported)
//  299  * - LENGTH: Descriptor length (either the requested number of bytes, or the length of the descriptor,
//  300  *           whichever is the smallest)
//  301  *
//  302  * <b>Data (IN)</b>:
//  303  * The descriptor(s)
//  304  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  305 void usbsrGetDescriptor(void)
usbsrGetDescriptor:
        CFI Block cfiBlock13 Using cfiCommon0
        CFI Function usbsrGetDescriptor
        CODE
//  306 {
        FUNCALL usbsrGetDescriptor, usbdpGetDeviceDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrGetDescriptor, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrGetDescriptor, usbdpGetStringDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 12, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 12, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xc
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        ; Saved register size: 12
        ; Auto size: 0
//  307    uint8 n;
//  308 
//  309    // Which descriptor?
//  310    switch (HI_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 3
        MOVX    A,@DPTR
        DEC     A
        JZ      ??usbsrGetDescriptor_0
        DEC     A
        JZ      ??usbsrGetDescriptor_1
        DEC     A
        JZ      ??usbsrGetDescriptor_2
        SJMP    ??usbsrGetDescriptor_3
//  311 
//  312    // Device descriptor
//  313    case DESC_TYPE_DEVICE:
//  314       usbSetupData.pBuffer = (uint8 __code*) usbdpGetDeviceDesc();
??usbsrGetDescriptor_0:
        ; Setup parameters for call to function usbdpGetDeviceDesc
        LCALL   ??usbdpGetDeviceDesc?relay
        LCALL   ?Subroutine7 & 0xFFFF
//  315       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
??CrossCallReturnLabel_8:
        INC     DPTR
        MOV     R3,#-0x80
??usbsrGetDescriptor_4:
        LCALL   ?C_GPTR_LOAD
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
??usbsrGetDescriptor_5:
        MOVX    @DPTR,A
//  316       break;
        LJMP    ??usbsrGetDescriptor_6 & 0xFFFF
//  317 
//  318    // Configuration descriptor
//  319    case DESC_TYPE_CONFIG:
//  320       usbSetupData.pBuffer = (uint8 __code*) usbdpGetConfigurationDesc(0, LO_UINT16(usbSetupHeader.value));
??usbsrGetDescriptor_1:
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R1,#0x0
        LCALL   ??usbdpGetConfigurationDesc?relay
        LCALL   ?Subroutine7 & 0xFFFF
//  321       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_CONFIG_LENGTH_LSB_IDX] +
//  322                                usbSetupData.pBuffer[DESC_CONFIG_LENGTH_MSB_IDX] * 256;
??CrossCallReturnLabel_9:
        MOV     R3,#-0x80
        MOV     A,R1
        ADD     A,#0x2
        INC     R1
        INC     R1
        MOV     A,R2
        ADDC    A,#0x0
        MOV     R2,A
        LCALL   ?C_GPTR_LOAD
        MOV     R4,A
        DEC     R1
        DEC     R1
        MOVX    A,@DPTR
        MOV     R2,A
        INC     DPTR
        MOV     A,R1
        ADD     A,#0x3
        INC     R1
        INC     R1
        INC     R1
        MOV     A,R2
        ADDC    A,#0x0
        MOV     R2,A
        LCALL   ?C_GPTR_LOAD
        MOV     R1,A
        MOV     A,R4
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        SJMP    ??usbsrGetDescriptor_5
//  323       break;
//  324 
//  325    // String descriptor
//  326    case DESC_TYPE_STRING:
//  327       // TODO: Implement language ID
//  328       usbSetupData.pBuffer = (uint8 *)usbdpGetStringDesc(LO_UINT16(usbSetupHeader.value));
??usbsrGetDescriptor_2:
        ; Setup parameters for call to function usbdpGetStringDesc
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??usbdpGetStringDesc?relay
        MOV     DPTR,#usbSetupData
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        LCALL   ?Subroutine14 & 0xFFFF
//  329       usbSetupData.bytesLeft = usbSetupData.pBuffer[DESC_LENGTH_IDX];
??CrossCallReturnLabel_22:
        INC     DPTR
        MOV     R3,#0x0
        SJMP    ??usbsrGetDescriptor_4
//  330       break;
//  331 
//  332    // Other descriptor type
//  333    default:
//  334       // Perform a table search (on index and value)
//  335       usbSetupData.pBuffer = NULL;
??usbsrGetDescriptor_3:
        MOV     DPTR,#usbSetupData
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
        INC     DPTR
        MOVX    @DPTR,A
//  336       for (n = 0; n < ((uint16)usbDescriptorMarker.pUsbDescLutEnd - (uint16)usbDescriptorMarker.pUsbDescLut) / sizeof(DESC_LUT_INFO); n++) {
        MOV     R2,A
        LJMP    ??usbsrGetDescriptor_7 & 0xFFFF
//  337          if ((usbDescriptorMarker.pUsbDescLut[n].valueMsb == HI_UINT16(usbSetupHeader.value))
//  338              && (usbDescriptorMarker.pUsbDescLut[n].valueLsb == LO_UINT16(usbSetupHeader.value))
//  339              && (usbDescriptorMarker.pUsbDescLut[n].indexMsb == HI_UINT16(usbSetupHeader.index))
//  340              && (usbDescriptorMarker.pUsbDescLut[n].indexLsb == LO_UINT16(usbSetupHeader.index)) )
??usbsrGetDescriptor_8:
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_2:
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#usbSetupHeader + 3
        MOVX    A,@DPTR
        MOV     R0,A
        POP     A
        CFI CFA_SP SP+0
        XRL     A,R0
        JZ      $+5
        LJMP    ??usbsrGetDescriptor_9 & 0xFFFF
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        LCALL   ?Subroutine5 & 0xFFFF
??CrossCallReturnLabel_3:
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R0,A
        POP     A
        CFI CFA_SP SP+0
        XRL     A,R0
        JZ      $+5
        LJMP    ??usbsrGetDescriptor_9 & 0xFFFF
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_0:
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#usbSetupHeader + 5
        MOVX    A,@DPTR
        MOV     R0,A
        POP     A
        CFI CFA_SP SP+0
        XRL     A,R0
        JNZ     ??usbsrGetDescriptor_9
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        LCALL   ?Subroutine4 & 0xFFFF
??CrossCallReturnLabel_1:
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R0,A
        POP     A
        CFI CFA_SP SP+0
        XRL     A,R0
        JNZ     ??usbsrGetDescriptor_9
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,#0x0
        MOV     A,#0x3
        MOV     R0,#?V0 + 0
        LCALL   ?S_SHL
        LCALL   ?Subroutine16 & 0xFFFF
??CrossCallReturnLabel_26:
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     ?V0 + 0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     ?V0 + 1,A
        MOV     DPTR,#usbSetupData
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x80
        MOVX    @DPTR,A
//  341          {
//  342             usbSetupData.pBuffer = usbDescriptorMarker.pUsbDescLut[n].pDescStart;
//  343             usbSetupData.bytesLeft = usbDescriptorMarker.pUsbDescLut[n].length;
        MOV     DPL,R0
        MOV     DPH,R1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     DPTR,#usbSetupData + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  344          }
//  345       }
??usbsrGetDescriptor_9:
        INC     R2
??usbsrGetDescriptor_7:
        MOV     ?V0 + 0,R2
        MOV     DPTR,#usbDescriptorMarker + 4
        LCALL   ?Subroutine6 & 0xFFFF
//  346    }
??CrossCallReturnLabel_4:
        MOV     DPH,#((usbDescriptorMarker + 6) >> 8) & 0xff
        MOV     DPL,#(usbDescriptorMarker + 6) & 0xff
        MOVX    A,@DPTR
        CLR     C
        SUBB    A,R0
        MOV     ?V0 + 2,A
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        MOV     ?V0 + 3,A
        MOV     A,#0x3
        MOV     R0,#?V0 + 2
        LCALL   ?US_SHR
        CLR     C
        MOV     A,?V0 + 0
        SUBB    A,?V0 + 2
        CLR     A
        SUBB    A,?V0 + 3
        JNC     $+5
        LJMP    ??usbsrGetDescriptor_8 & 0xFFFF
//  347 
//  348    // Stall EP0 if no descriptor was found
//  349    if (usbSetupData.pBuffer == NULL) usbfwData.ep0Status = EP_STALL;
??usbsrGetDescriptor_6:
        MOV     DPTR,#usbSetupData
        MOVX    A,@DPTR
        MOV     R4,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R5,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R6,A
        MOV     A,R4
        ORL     A,R5
        ORL     A,R6
        MOV     DPTR,#usbfwData + 7
        JNZ     ??usbsrGetDescriptor_10
        MOV     A,#0x4
        SJMP    ??usbsrGetDescriptor_11
//  350 
//  351    if (usbfwData.ep0Status != EP_STALL) {
??usbsrGetDescriptor_10:
        MOVX    A,@DPTR
        XRL     A,#0x4
        JZ      ??usbsrGetDescriptor_12
//  352 
//  353       // Limit the returned descriptor size (the PC wants to know about sizes before
//  354       // polling the complete descriptors)
//  355       if (usbSetupData.bytesLeft > usbSetupHeader.length) {
        MOV     DPTR,#usbSetupData + 3
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_5:
        MOV     DPH,#((usbSetupHeader + 6) >> 8) & 0xff
        MOV     DPL,#(usbSetupHeader + 6) & 0xff
        CLR     C
        MOVX    A,@DPTR
        SUBB    A,R0
        INC     DPTR
        MOVX    A,@DPTR
        SUBB    A,R1
        JNC     ??usbsrGetDescriptor_13
//  356          usbSetupData.bytesLeft = usbSetupHeader.length;
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ?Subroutine6 & 0xFFFF
//  357       }
??CrossCallReturnLabel_6:
        MOV     DPTR,#usbSetupData + 3
        MOV     A,R0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R1
        MOVX    @DPTR,A
//  358 
//  359       usbfwData.ep0Status = EP_TX;
??usbsrGetDescriptor_13:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x1
??usbsrGetDescriptor_11:
        MOVX    @DPTR,A
//  360    }
//  361 
//  362 } // usbsrGetDescriptor
??usbsrGetDescriptor_12:
        MOV     R7,#0x4
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock13

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine7:
        CFI Block cfiCond14 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_8
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond15 Using cfiCommon0
        CFI (cfiCond15) NoFunction
        CFI (cfiCond15) Conditional ??CrossCallReturnLabel_9
        CFI (cfiCond15) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond15) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond15) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond15) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond15) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond15) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond15) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond15) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond15) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond15) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond15) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond15) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond15) CFA_SP SP+0
        CFI (cfiCond15) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker16 Using cfiCommon1
        CFI (cfiPicker16) NoFunction
        CFI (cfiPicker16) Picker
        MOV     DPTR,#usbSetupData
        MOV     A,R2
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,R3
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#-0x80
        LCALL   ?Subroutine14 & 0xFFFF
??CrossCallReturnLabel_23:
        RET
        CFI EndBlock cfiCond14
        CFI EndBlock cfiCond15
        CFI EndBlock cfiPicker16

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine14:
        CFI Block cfiCond17 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_22
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond18 Using cfiCommon0
        CFI (cfiCond18) NoFunction
        CFI (cfiCond18) Conditional ??CrossCallReturnLabel_23, ??CrossCallReturnLabel_8
        CFI (cfiCond18) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond18) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond18) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond18) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond18) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond18) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond18) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond18) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond18) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond18) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond18) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond18) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond18) CFA_SP SP+0
        CFI (cfiCond18) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond19 Using cfiCommon0
        CFI (cfiCond19) NoFunction
        CFI (cfiCond19) Conditional ??CrossCallReturnLabel_23, ??CrossCallReturnLabel_9
        CFI (cfiCond19) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond19) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond19) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond19) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond19) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond19) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond19) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond19) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond19) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond19) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond19) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond19) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond19) CFA_SP SP+0
        CFI (cfiCond19) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker20 Using cfiCommon1
        CFI (cfiPicker20) NoFunction
        CFI (cfiPicker20) Picker
        MOVX    @DPTR,A
        MOV     DPTR,#usbSetupData
        MOVX    A,@DPTR
        MOV     R1,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R2,A
        RET
        CFI EndBlock cfiCond17
        CFI EndBlock cfiCond18
        CFI EndBlock cfiCond19
        CFI EndBlock cfiPicker20

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine5:
        CFI Block cfiCond21 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond22 Using cfiCommon0
        CFI (cfiCond22) NoFunction
        CFI (cfiCond22) Conditional ??CrossCallReturnLabel_3
        CFI (cfiCond22) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond22) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond22) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond22) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond22) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond22) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond22) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond22) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond22) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond22) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond22) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond22) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond22) CFA_SP SP+0
        CFI (cfiCond22) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker23 Using cfiCommon1
        CFI (cfiPicker23) NoFunction
        CFI (cfiPicker23) Picker
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_21:
        RET
        CFI EndBlock cfiCond21
        CFI EndBlock cfiCond22
        CFI EndBlock cfiPicker23

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine13:
        CFI Block cfiCond24 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_21, ??CrossCallReturnLabel_2
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond25 Using cfiCommon0
        CFI (cfiCond25) NoFunction
        CFI (cfiCond25) Conditional ??CrossCallReturnLabel_21, ??CrossCallReturnLabel_3
        CFI (cfiCond25) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond25) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond25) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond25) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond25) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond25) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond25) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond25) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond25) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond25) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond25) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond25) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond25) CFA_SP SP+0
        CFI (cfiCond25) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond26 Using cfiCommon0
        CFI (cfiCond26) NoFunction
        CFI (cfiCond26) Conditional ??CrossCallReturnLabel_20, ??CrossCallReturnLabel_0
        CFI (cfiCond26) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond26) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond26) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond26) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond26) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond26) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond26) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond26) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond26) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond26) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond26) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond26) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond26) CFA_SP SP+0
        CFI (cfiCond26) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond27 Using cfiCommon0
        CFI (cfiCond27) NoFunction
        CFI (cfiCond27) Conditional ??CrossCallReturnLabel_20, ??CrossCallReturnLabel_1
        CFI (cfiCond27) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond27) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond27) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond27) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond27) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond27) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond27) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond27) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond27) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond27) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond27) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond27) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond27) CFA_SP SP+0
        CFI (cfiCond27) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker28 Using cfiCommon1
        CFI (cfiPicker28) NoFunction
        CFI (cfiPicker28) Picker
        LCALL   ?Subroutine16 & 0xFFFF
??CrossCallReturnLabel_27:
        MOV     DPL,R0
        MOV     DPH,A
        RET
        CFI EndBlock cfiCond24
        CFI EndBlock cfiCond25
        CFI EndBlock cfiCond26
        CFI EndBlock cfiCond27
        CFI EndBlock cfiPicker28

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine16:
        CFI Block cfiCond29 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_26
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond30 Using cfiCommon0
        CFI (cfiCond30) NoFunction
        CFI (cfiCond30) Conditional ??CrossCallReturnLabel_27, ??CrossCallReturnLabel_21, ??CrossCallReturnLabel_2
        CFI (cfiCond30) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond30) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond30) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond30) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond30) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond30) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond30) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond30) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond30) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond30) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond30) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond30) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond30) CFA_SP SP+0
        CFI (cfiCond30) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond31 Using cfiCommon0
        CFI (cfiCond31) NoFunction
        CFI (cfiCond31) Conditional ??CrossCallReturnLabel_27, ??CrossCallReturnLabel_21, ??CrossCallReturnLabel_3
        CFI (cfiCond31) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond31) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond31) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond31) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond31) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond31) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond31) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond31) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond31) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond31) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond31) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond31) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond31) CFA_SP SP+0
        CFI (cfiCond31) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond32 Using cfiCommon0
        CFI (cfiCond32) NoFunction
        CFI (cfiCond32) Conditional ??CrossCallReturnLabel_27, ??CrossCallReturnLabel_20, ??CrossCallReturnLabel_0
        CFI (cfiCond32) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond32) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond32) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond32) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond32) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond32) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond32) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond32) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond32) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond32) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond32) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond32) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond32) CFA_SP SP+0
        CFI (cfiCond32) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond33 Using cfiCommon0
        CFI (cfiCond33) NoFunction
        CFI (cfiCond33) Conditional ??CrossCallReturnLabel_27, ??CrossCallReturnLabel_20, ??CrossCallReturnLabel_1
        CFI (cfiCond33) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond33) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond33) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond33) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond33) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond33) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond33) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond33) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond33) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond33) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond33) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond33) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond33) CFA_SP SP+0
        CFI (cfiCond33) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker34 Using cfiCommon1
        CFI (cfiPicker34) NoFunction
        CFI (cfiPicker34) Picker
        MOV     DPTR,#usbDescriptorMarker + 4
        MOVX    A,@DPTR
        ADD     A,?V0 + 0
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,?V0 + 1
        RET
        CFI EndBlock cfiCond29
        CFI EndBlock cfiCond30
        CFI EndBlock cfiCond31
        CFI EndBlock cfiCond32
        CFI EndBlock cfiCond33
        CFI EndBlock cfiPicker34

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine4:
        CFI Block cfiCond35 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_0
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond36 Using cfiCommon0
        CFI (cfiCond36) NoFunction
        CFI (cfiCond36) Conditional ??CrossCallReturnLabel_1
        CFI (cfiCond36) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond36) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond36) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond36) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond36) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond36) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond36) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond36) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond36) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond36) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond36) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond36) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond36) CFA_SP SP+0
        CFI (cfiCond36) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiPicker37 Using cfiCommon1
        CFI (cfiPicker37) NoFunction
        CFI (cfiPicker37) Picker
        LCALL   ?Subroutine13 & 0xFFFF
??CrossCallReturnLabel_20:
        INC     DPTR
        INC     DPTR
        RET
        CFI EndBlock cfiCond35
        CFI EndBlock cfiCond36
        CFI EndBlock cfiPicker37
//  363 
//  364 
//  365 
//  366 /** \brief Internally used function that configures all endpoints for the specified interface
//  367  *
//  368  * The new endpoint setup overwrites the old, without any warning. Unused endpoints keep their current
//  369  * setup. The user is responsible for ensuring that no endpoint buffers overwrite each other, and that
//  370  * interfaces do not cause conflicts. The pUsbDblbufLutInfo table must contain an entry for each
//  371  * interface descriptor to define endpoint double-buffering.
//  372  *
//  373  * \param[in]       *pInterface
//  374  *     A pointer to the interface descriptor
//  375  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  376 static void ConfigureEndpoints(USB_INTERFACE_DESCRIPTOR __code *pInterface)
ConfigureEndpoints:
        CFI Block cfiBlock38 Using cfiCommon0
        CFI Function ConfigureEndpoints
        CODE
//  377 {
        FUNCALL ConfigureEndpoints, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 18, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 18, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0x12
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 18)
        ; Saved register size: 18
        ; Auto size: 0
        MOV     A,R2
        MOV     R6,A
        MOV     A,R3
        MOV     R7,A
//  378    uint8 n;
//  379    uint16 maxpRegValue;
//  380    uint8 csRegValue;
//  381    uint8 endpoint;
//  382    USB_ENDPOINT_DESCRIPTOR __code *pEndpoint;
//  383    DBLBUF_LUT_INFO __code *pUsbDblbufLutInfo;
//  384 
//  385    // Locate the double buffer settings
//  386    if (pInterface->bNumEndpoints) {
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        JZ      ??ConfigureEndpoints_0
//  387        pUsbDblbufLutInfo = (DBLBUF_LUT_INFO __code*) usbDescriptorMarker.pUsbDblbufLut;
        MOV     DPTR,#usbDescriptorMarker + 8
        LCALL   ?Subroutine6 & 0xFFFF
??CrossCallReturnLabel_7:
        MOV     ?V0 + 0,R0
        MOV     ?V0 + 1,R1
        SJMP    ??ConfigureEndpoints_1
//  388        while (pUsbDblbufLutInfo->pInterface != pInterface) {
//  389           pUsbDblbufLutInfo++;
??ConfigureEndpoints_2:
        MOV     A,?V0 + 0
        ADD     A,#0x4
        MOV     ?V0 + 0,A
        MOV     A,?V0 + 1
        ADDC    A,#0x0
        MOV     ?V0 + 1,A
//  390        }
??ConfigureEndpoints_1:
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,#0x1
        MOVC    A,@A+DPTR
        MOV     R1,A
        MOV     A,R6
        XRL     A,R0
        JNZ     ??ConfigureEndpoints_3
        MOV     A,R7
        XRL     A,R1
??ConfigureEndpoints_3:
        JNZ     ??ConfigureEndpoints_2
//  391    }
//  392 
//  393    // For each endpoint in this interface
//  394    for (n = 0; n < pInterface->bNumEndpoints; n++) {
??ConfigureEndpoints_0:
        MOV     ?V0 + 4,#0x0
        SJMP    ??ConfigureEndpoints_4
//  395       if (pEndpoint = usbdpFindNext(DESC_TYPE_ENDPOINT, 0)) {
//  396 
//  397          // Get the endpoint index
//  398          endpoint = pEndpoint->bEndpointAddress & 0x0F;
//  399          USBFW_SELECT_ENDPOINT(endpoint);
//  400 
//  401          csRegValue = 0x00;
//  402          maxpRegValue = (pEndpoint->wMaxPacketSize + 7) >> 3;
//  403 
//  404          // For IN endpoints...
//  405          if (pEndpoint->bEndpointAddress & 0x80) {
//  406 
//  407             // Clear data toggle, and flush twice (due to double buffering)
//  408             USBCSIL = USBCSIL_CLR_DATA_TOG | USBCSIL_FLUSH_PACKET;
//  409             USBCSIL = USBCSIL_FLUSH_PACKET;
//  410 
//  411             // USBCSIH
//  412             if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSIH_ISO;  // ISO flag
//  413             if (pUsbDblbufLutInfo->inMask & (1 << endpoint)) csRegValue |= USBCSIH_IN_DBL_BUF;          // Double buffering
//  414             USBCSIH = csRegValue;
//  415 
//  416             // Max transfer size
//  417             USBMAXI = maxpRegValue;
//  418 
//  419             // Endpoint status
//  420             usbfwData.pEpInStatus[endpoint - 1] = EP_IDLE;
//  421 
//  422          // For OUT endpoints...
//  423          } else {
//  424 
//  425             // Clear data toggle, and flush twice (due to double buffering)
//  426             USBCSOL = USBCSOL_CLR_DATA_TOG | USBCSOL_FLUSH_PACKET;
??ConfigureEndpoints_5:
        MOV     DPTR,#0x6214
        MOV     A,#-0x70
        MOVX    @DPTR,A
//  427             USBCSOL = USBCSOL_FLUSH_PACKET;
        MOV     A,#0x10
        LCALL   ?Subroutine8 & 0xFFFF
//  428 
//  429             // USBCSOH
//  430             if ((pEndpoint->bmAttributes & EP_ATTR_TYPE_BM) == EP_ATTR_ISO) csRegValue |= USBCSOH_ISO;  // ISO flag
??CrossCallReturnLabel_10:
        JNZ     ??ConfigureEndpoints_6
        MOV     R1,#0x40
//  431             if (pUsbDblbufLutInfo->outMask & (1 << endpoint)) csRegValue |= USBCSOH_OUT_DBL_BUF;        // Double buffering
??ConfigureEndpoints_6:
        MOV     ?V0 + 2,#0x1
        MOV     ?V0 + 3,#0x0
        MOV     A,?V0 + 6
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        INC     DPTR
        MOVC    A,@A+DPTR
        ANL     A,?V0 + 2
        JZ      ??ConfigureEndpoints_7
        MOV     A,R1
        SETB    0xE0 /* A   */.0
        MOV     R1,A
//  432             USBCSOH = csRegValue;
??ConfigureEndpoints_7:
        MOV     A,R1
        MOV     DPTR,#0x6215
        MOVX    @DPTR,A
//  433 
//  434             // Max transfer size
//  435             USBMAXO = maxpRegValue;
        MOV     A,R2
        MOV     DPTR,#0x6213
        MOVX    @DPTR,A
//  436 
//  437             // Endpoint status
//  438             usbfwData.pEpOutStatus[endpoint - 1] = EP_IDLE;
        MOV     A,#(usbfwData + 12) & 0xff
        ADD     A,?V0 + 6
        MOV     DPL,A
        MOV     A,#((usbfwData + 12) >> 8) & 0xff
??ConfigureEndpoints_8:
        ADDC    A,#0x0
        MOV     DPH,A
        CLR     A
        MOVX    @DPTR,A
//  439          }
//  440          USBFW_SELECT_ENDPOINT(0);
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
??ConfigureEndpoints_9:
        INC     ?V0 + 4
??ConfigureEndpoints_4:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,?V0 + 4
        CLR     C
        SUBB    A,R0
        JC      $+5
        LJMP    ??ConfigureEndpoints_10 & 0xFFFF
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x5
        LCALL   ??usbdpFindNext?relay
        MOV     ?V0 + 2,R2
        MOV     ?V0 + 3,R3
        MOV     A,R2
        ORL     A,?V0 + 3
        JZ      ??ConfigureEndpoints_9
        MOV     A,R2
        ADD     A,#0x2
        MOV     R0,A
        MOV     A,R3
        ADDC    A,#0x0
        MOV     R1,A
        MOV     A,R0
        MOV     R4,A
        MOV     A,R1
        MOV     R5,A
        MOV     DPL,R4
        MOV     DPH,R5
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,#0xf
        MOV     ?V0 + 6,A
        MOV     DPTR,#0x620e
        MOVX    @DPTR,A
        MOV     R1,#0x0
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ADD     A,#0x7
        MOV     ?V0 + 8,A
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ADDC    A,#0x0
        MOV     ?V0 + 9,A
        MOV     A,#0x3
        MOV     R0,#?V0 + 8
        LCALL   ?US_SHR
        MOV     R2,?V0 + 8
        MOV     DPL,R4
        MOV     DPH,R5
        MOVC    A,@A+DPTR
        MOV     C,0xE0 /* A   */.7
        JC      $+5
        LJMP    ??ConfigureEndpoints_5 & 0xFFFF
        MOV     DPTR,#0x6211
        MOV     A,#0x48
        MOVX    @DPTR,A
        MOV     A,#0x8
        LCALL   ?Subroutine8 & 0xFFFF
??CrossCallReturnLabel_11:
        JNZ     ??ConfigureEndpoints_11
        MOV     R1,#0x40
??ConfigureEndpoints_11:
        MOV     ?V0 + 2,#0x1
        MOV     ?V0 + 3,#0x0
        MOV     A,?V0 + 6
        MOV     R0,#?V0 + 2
        LCALL   ?S_SHL
        MOV     DPL,?V0 + 0
        MOV     DPH,?V0 + 1
        INC     DPTR
        INC     DPTR
        MOVC    A,@A+DPTR
        ANL     A,?V0 + 2
        JZ      ??ConfigureEndpoints_12
        MOV     A,R1
        SETB    0xE0 /* A   */.0
        MOV     R1,A
??ConfigureEndpoints_12:
        MOV     A,R1
        MOV     DPTR,#0x6212
        MOVX    @DPTR,A
        MOV     A,R2
        MOV     DPTR,#0x6210
        MOVX    @DPTR,A
        MOV     ?V0 + 2,?V0 + 6
        MOV     A,#(usbfwData + 7) & 0xff
        ADD     A,?V0 + 2
        MOV     DPL,A
        MOV     A,#((usbfwData + 7) >> 8) & 0xff
        LJMP    ??ConfigureEndpoints_8 & 0xFFFF
//  441       }
//  442    }
//  443 } // ConfigureEndpoints
??ConfigureEndpoints_10:
        MOV     R7,#0xa
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock38

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine8:
        CFI Block cfiCond39 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_10
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 18)
        CFI Block cfiCond40 Using cfiCommon0
        CFI (cfiCond40) NoFunction
        CFI (cfiCond40) Conditional ??CrossCallReturnLabel_11
        CFI (cfiCond40) R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI (cfiCond40) VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI (cfiCond40) V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond40) V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond40) V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond40) V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond40) V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond40) V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond40) V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond40) V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond40) V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond40) V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond40) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond40) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond40) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond40) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond40) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond40) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond40) CFA_SP SP+0
        CFI (cfiCond40) CFA_XSP16 add(XSP16, 18)
        CFI Block cfiPicker41 Using cfiCommon1
        CFI (cfiPicker41) NoFunction
        CFI (cfiPicker41) Picker
        MOVX    @DPTR,A
        MOV     DPL,?V0 + 2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        ANL     A,#0x3
        XRL     A,#0x1
        RET
        CFI EndBlock cfiCond39
        CFI EndBlock cfiCond40
        CFI EndBlock cfiPicker41

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine6:
        CFI Block cfiCond42 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_4
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond43 Using cfiCommon0
        CFI (cfiCond43) NoFunction
        CFI (cfiCond43) Conditional ??CrossCallReturnLabel_5
        CFI (cfiCond43) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond43) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond43) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond43) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond43) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond43) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond43) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond43) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond43) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond43) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond43) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond43) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond43) CFA_SP SP+0
        CFI (cfiCond43) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond44 Using cfiCommon0
        CFI (cfiCond44) NoFunction
        CFI (cfiCond44) Conditional ??CrossCallReturnLabel_6
        CFI (cfiCond44) R6 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond44) VB load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond44) V0 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond44) V1 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond44) V2 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond44) V3 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond44) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond44) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond44) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond44) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond44) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond44) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond44) CFA_SP SP+0
        CFI (cfiCond44) CFA_XSP16 add(XSP16, 12)
        CFI Block cfiCond45 Using cfiCommon0
        CFI (cfiCond45) NoFunction
        CFI (cfiCond45) Conditional ??CrossCallReturnLabel_7
        CFI (cfiCond45) R6 load(1, XDATA, add(CFA_XSP16, literal(-18)))
        CFI (cfiCond45) VB load(1, XDATA, add(CFA_XSP16, literal(-17)))
        CFI (cfiCond45) V0 load(1, XDATA, add(CFA_XSP16, literal(-16)))
        CFI (cfiCond45) V1 load(1, XDATA, add(CFA_XSP16, literal(-15)))
        CFI (cfiCond45) V2 load(1, XDATA, add(CFA_XSP16, literal(-14)))
        CFI (cfiCond45) V3 load(1, XDATA, add(CFA_XSP16, literal(-13)))
        CFI (cfiCond45) V4 load(1, XDATA, add(CFA_XSP16, literal(-12)))
        CFI (cfiCond45) V5 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond45) V6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond45) V7 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond45) V8 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond45) V9 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond45) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond45) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond45) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond45) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond45) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond45) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond45) CFA_SP SP+0
        CFI (cfiCond45) CFA_XSP16 add(XSP16, 18)
        CFI Block cfiPicker46 Using cfiCommon1
        CFI (cfiPicker46) NoFunction
        CFI (cfiPicker46) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        RET
        CFI EndBlock cfiCond42
        CFI EndBlock cfiCond43
        CFI EndBlock cfiCond44
        CFI EndBlock cfiCond45
        CFI EndBlock cfiPicker46
//  444 
//  445 
//  446 
//  447 
//  448 /** \brief Processes the \ref GET_CONFIGURATION request (returns the current device configuration value)
//  449  *
//  450  * If the returned value is 0, the device is not configured (not in the configured state)
//  451  *
//  452  * <b>Parameters</b>:
//  453  * - VALUE: Always 0
//  454  * - INDEX: Always 0
//  455  * - LENGTH: Always 1
//  456  *
//  457  * <b>Data (IN)</b>:
//  458  * The non-zero \ref USB_CONFIGURATION_DESCRIPTOR.bConfigurationValue of the currently selected
//  459  * configuration.
//  460  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  461 void usbsrGetConfiguration(void)
usbsrGetConfiguration:
        CFI Block cfiBlock47 Using cfiCommon0
        CFI Function usbsrGetConfiguration
        CODE
//  462 {
        PUSH    DPL
        CFI DPL0 Frame(CFA_SP, 4)
        CFI CFA_SP SP+-4
        PUSH    DPH
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        ; Saved register size: 2
        ; Auto size: 0
//  463 
//  464    // Sanity check
//  465    if (usbSetupHeader.value || usbSetupHeader.index || (usbSetupHeader.length != 1)) {
        LCALL   ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_37:
        JNZ     ??usbsrGetConfiguration_0
        INC     DPTR
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_32:
        JNZ     ??usbsrGetConfiguration_0
        INC     DPTR
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrGetConfiguration_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetConfiguration_1:
        JZ      ??usbsrGetConfiguration_2
//  466       usbfwData.ep0Status = EP_STALL;
??usbsrGetConfiguration_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_12
//  467 
//  468    // Return the current configuration
//  469    } else {
//  470       usbSetupData.pBuffer = &usbfwData.configurationValue;
??usbsrGetConfiguration_2:
        MOV     DPTR,#usbSetupData
        MOV     A,#(usbfwData + 1) & 0xff
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,#((usbfwData + 1) >> 8) & 0xff
        LCALL   ?Subroutine9 & 0xFFFF
//  471       usbSetupData.bytesLeft = 1;
//  472       usbfwData.ep0Status = EP_TX;
//  473    }
??CrossCallReturnLabel_12:
        MOVX    @DPTR,A
//  474 
//  475 } // usbsrGetConfiguration
        LJMP    ?Subroutine1 & 0xFFFF
        CFI EndBlock cfiBlock47
//  476 
//  477 
//  478 
//  479 
//  480 /** \brief Processes the \ref SET_CONFIGURATION request (sets the device configuration)
//  481  *
//  482  * The configuration value must either be 0, in which case the device enters the address state, or it
//  483  * must match a configuration value from one of the USB configuration descriptors. If there is a match,
//  484  * the device enters the configured state.
//  485  *
//  486  * This request resets all interfaces to alternate setting 0, and uses the \c ConfigureEndpoints()
//  487  * function to automatically setup all endpoint registers.
//  488  *
//  489  * <b>Parameters</b>:
//  490  * - VALUE: The configuration value (0-255)
//  491  * - INDEX: Always 0
//  492  * - LENGTH: Always 0
//  493  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  494 void usbsrSetConfiguration(void)
usbsrSetConfiguration:
        CFI Block cfiBlock48 Using cfiCommon0
        CFI Function usbsrSetConfiguration
        CODE
//  495 {
        FUNCALL usbsrSetConfiguration, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbdpGetConfigurationDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbdpFindNext
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, ConfigureEndpoints
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbfwSetAllEpStatus
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetConfiguration, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 11, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 11, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
//  496    uint8 n;
//  497    USB_CONFIGURATION_DESCRIPTOR __code *pConfiguration;
//  498    USB_INTERFACE_DESCRIPTOR __code *pInterface;
//  499 
//  500    // Sanity check
//  501    if ((usbfwData.usbState == DEV_DEFAULT) || usbSetupHeader.index || usbSetupHeader.length || HI_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x2
        JZ      ??usbsrSetConfiguration_0
        MOV     DPTR,#usbSetupHeader + 4
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_33:
        JNZ     ??usbsrSetConfiguration_0
        INC     DPTR
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_34:
        JNZ     ??usbsrSetConfiguration_0
        MOV     DPTR,#usbSetupHeader + 3
        MOVX    A,@DPTR
        JZ      ??usbsrSetConfiguration_1
//  502       usbfwData.ep0Status = EP_STALL;
??usbsrSetConfiguration_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        LJMP    ??usbsrSetConfiguration_2 & 0xFFFF
//  503 
//  504    // Default endpoint setup
//  505    } else {
//  506       usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGING, 0);
??usbsrSetConfiguration_1:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        MOV     R1,#0x1
        LCALL   ??usbsrHookProcessEvent?relay
//  507 
//  508       // Configure relevant endpoints
//  509       if (LO_UINT16(usbSetupHeader.value)) {
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        JZ      ??usbsrSetConfiguration_3
//  510 
//  511          // Find the correct configuration descriptor...
//  512          pConfiguration = usbdpGetConfigurationDesc(LO_UINT16(usbSetupHeader.value), 0);
        ; Setup parameters for call to function usbdpGetConfigurationDesc
        MOV     R2,#0x0
        MOV     R1,A
        LCALL   ??usbdpGetConfigurationDesc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R6,?V0 + 0
        MOV     R7,?V0 + 1
//  513 
//  514          // If it exists...
//  515          if (pConfiguration) {
        MOV     A,R6
        ORL     A,R7
        JZ      ??usbsrSetConfiguration_4
//  516             usbfwData.usbState = DEV_CONFIGURED;
        MOV     DPTR,#usbfwData
        MOV     A,#0x4
        MOVX    @DPTR,A
//  517             usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     DPTR,#usbfwData + 1
        MOVX    @DPTR,A
//  518 
//  519             // For each interface...
//  520             for (n = 0; n < pConfiguration->bNumInterfaces; n++) {
        MOV     ?V0 + 2,#0x0
??usbsrSetConfiguration_5:
        MOV     DPL,R6
        MOV     DPH,R7
        INC     DPTR
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        MOV     A,?V0 + 2
        CLR     C
        SUBB    A,R0
        JNC     ??usbsrSetConfiguration_6
//  521                usbfwData.pAlternateSetting[n] = 0x00;
        MOV     ?V0 + 0,?V0 + 2
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_18:
        CLR     A
        MOVX    @DPTR,A
//  522 
//  523                // Look only for alternate setting 0
//  524                do {
//  525                   pInterface = usbdpFindNext(DESC_TYPE_INTERFACE, 0);
??usbsrSetConfiguration_7:
        ; Setup parameters for call to function usbdpFindNext
        MOV     R2,#0x0
        MOV     R1,#0x4
        LCALL   ??usbdpFindNext?relay
//  526                } while (pInterface->bAlternateSetting != usbfwData.pAlternateSetting[n]);
        MOV     DPL,R2
        MOV     DPH,R3
        INC     DPTR
        INC     DPTR
        INC     DPTR
        CLR     A
        MOVC    A,@A+DPTR
        MOV     R0,A
        LCALL   ?Subroutine12 & 0xFFFF
??CrossCallReturnLabel_19:
        MOVX    A,@DPTR
        XRL     A,R0
        JNZ     ??usbsrSetConfiguration_7
//  527 
//  528                // Configure all endpoints in this interface
//  529                ConfigureEndpoints(pInterface);
        ; Setup parameters for call to function ConfigureEndpoints
        LCALL   ??ConfigureEndpoints?relay
//  530             }
        INC     ?V0 + 2
        SJMP    ??usbsrSetConfiguration_5
//  531 
//  532          // If not, then stall the endpoint
//  533          } else {
//  534             usbfwData.ep0Status = EP_STALL;
??usbsrSetConfiguration_4:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbsrSetConfiguration_6
//  535          }
//  536 
//  537       // Unconfigure endpoints
//  538       } else {
//  539          usbfwData.configurationValue = LO_UINT16(usbSetupHeader.value);
??usbsrSetConfiguration_3:
        MOV     DPTR,#usbfwData + 1
        MOVX    @DPTR,A
//  540          usbfwData.usbState = DEV_ADDRESS;
        MOV     DPTR,#usbfwData
        MOV     A,#0x3
        MOVX    @DPTR,A
//  541          usbfwSetAllEpStatus(EP_HALT);
        ; Setup parameters for call to function usbfwSetAllEpStatus
        MOV     R1,A
        LCALL   ??usbfwSetAllEpStatus?relay
//  542       }
//  543       usbsrHookProcessEvent(USBSR_EVENT_CONFIGURATION_CHANGED, 0);
??usbsrSetConfiguration_6:
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     R2,#0x0
        MOV     R1,#0x2
        LCALL   ??usbsrHookProcessEvent?relay
        CFI EndBlock cfiBlock48
//  544    }
//  545 
//  546 } // usbsrSetConfiguration
??usbsrSetConfiguration_2:
        REQUIRE ?Subroutine2
        ; // Fall through to label ?Subroutine2

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine2:
        CFI Block cfiBlock49 Using cfiCommon0
        CFI NoFunction
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 11)
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        MOV     R7,#0x3
        LJMP    ?BANKED_LEAVE_XDATA
        CFI EndBlock cfiBlock49

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine12:
        CFI Block cfiCond50 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_18
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 11)
        CFI Block cfiCond51 Using cfiCommon0
        CFI (cfiCond51) NoFunction
        CFI (cfiCond51) Conditional ??CrossCallReturnLabel_19
        CFI (cfiCond51) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond51) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond51) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond51) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond51) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond51) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond51) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond51) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond51) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond51) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond51) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond51) CFA_SP SP+0
        CFI (cfiCond51) CFA_XSP16 add(XSP16, 11)
        CFI Block cfiPicker52 Using cfiCommon1
        CFI (cfiPicker52) NoFunction
        CFI (cfiPicker52) Picker
        MOV     A,#(usbfwData + 2) & 0xff
        ADD     A,?V0 + 0
        MOV     DPL,A
        MOV     A,#((usbfwData + 2) >> 8) & 0xff
        ADDC    A,#0x0
        MOV     DPH,A
        RET
        CFI EndBlock cfiCond50
        CFI EndBlock cfiCond51
        CFI EndBlock cfiPicker52

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine3:
        CFI Block cfiCond53 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_36
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond54 Using cfiCommon0
        CFI (cfiCond54) NoFunction
        CFI (cfiCond54) Conditional ??CrossCallReturnLabel_37
        CFI (cfiCond54) DPL0 Frame(CFA_SP, 4)
        CFI (cfiCond54) DPH0 Frame(CFA_SP, 5)
        CFI (cfiCond54) CFA_SP SP+-5
        CFI Block cfiCond55 Using cfiCommon0
        CFI (cfiCond55) NoFunction
        CFI (cfiCond55) Conditional ??CrossCallReturnLabel_38
        CFI (cfiCond55) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond55) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond55) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond55) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond55) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond55) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond55) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond55) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond55) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond55) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond55) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond55) CFA_SP SP+0
        CFI (cfiCond55) CFA_XSP16 add(XSP16, 11)
        CFI Block cfiPicker56 Using cfiCommon1
        CFI (cfiPicker56) NoFunction
        CFI (cfiPicker56) Picker
        MOV     DPTR,#usbSetupHeader + 2
        CFI EndBlock cfiCond53
        CFI EndBlock cfiCond54
        CFI EndBlock cfiCond55
        CFI EndBlock cfiPicker56
        REQUIRE ??Subroutine17_0
        ; // Fall through to label ??Subroutine17_0

        RSEG BANKED_CODE:CODE:NOROOT(0)
??Subroutine17_0:
        CFI Block cfiCond57 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_28
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond58 Using cfiCommon0
        CFI (cfiCond58) NoFunction
        CFI (cfiCond58) Conditional ??CrossCallReturnLabel_29
        CFI (cfiCond58) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond58) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond58) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond58) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond58) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond58) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond58) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond58) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond58) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond58) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond58) CFA_SP SP+0
        CFI (cfiCond58) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond59 Using cfiCommon0
        CFI (cfiCond59) NoFunction
        CFI (cfiCond59) Conditional ??CrossCallReturnLabel_30
        CFI (cfiCond59) DPL0 Frame(CFA_SP, 4)
        CFI (cfiCond59) DPH0 Frame(CFA_SP, 5)
        CFI (cfiCond59) CFA_SP SP+-5
        CFI Block cfiCond60 Using cfiCommon0
        CFI (cfiCond60) NoFunction
        CFI (cfiCond60) Conditional ??CrossCallReturnLabel_31
        CFI (cfiCond60) DPL0 Frame(CFA_SP, 4)
        CFI (cfiCond60) DPH0 Frame(CFA_SP, 5)
        CFI (cfiCond60) CFA_SP SP+-5
        CFI Block cfiCond61 Using cfiCommon0
        CFI (cfiCond61) NoFunction
        CFI (cfiCond61) Conditional ??CrossCallReturnLabel_32
        CFI (cfiCond61) DPL0 Frame(CFA_SP, 4)
        CFI (cfiCond61) DPH0 Frame(CFA_SP, 5)
        CFI (cfiCond61) CFA_SP SP+-5
        CFI Block cfiCond62 Using cfiCommon0
        CFI (cfiCond62) NoFunction
        CFI (cfiCond62) Conditional ??CrossCallReturnLabel_33
        CFI (cfiCond62) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond62) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond62) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond62) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond62) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond62) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond62) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond62) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond62) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond62) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond62) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond62) CFA_SP SP+0
        CFI (cfiCond62) CFA_XSP16 add(XSP16, 11)
        CFI Block cfiCond63 Using cfiCommon0
        CFI (cfiCond63) NoFunction
        CFI (cfiCond63) Conditional ??CrossCallReturnLabel_34
        CFI (cfiCond63) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond63) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond63) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond63) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond63) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond63) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond63) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond63) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond63) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond63) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond63) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond63) CFA_SP SP+0
        CFI (cfiCond63) CFA_XSP16 add(XSP16, 11)
        CFI Block cfiCond64 Using cfiCommon0
        CFI (cfiCond64) NoFunction
        CFI (cfiCond64) Conditional ??CrossCallReturnLabel_35
        CFI (cfiCond64) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond64) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond64) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond64) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond64) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond64) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond64) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond64) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond64) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond64) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond64) CFA_SP SP+0
        CFI (cfiCond64) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond65 Using cfiCommon0
        CFI (cfiCond65) NoFunction
        CFI (cfiCond65) Conditional ??CrossCallReturnLabel_36
        CFI (cfiCond65) R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond65) VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond65) V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond65) V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond65) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond65) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond65) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond65) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond65) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond65) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond65) CFA_SP SP+0
        CFI (cfiCond65) CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond66 Using cfiCommon0
        CFI (cfiCond66) NoFunction
        CFI (cfiCond66) Conditional ??CrossCallReturnLabel_37
        CFI (cfiCond66) DPL0 Frame(CFA_SP, 4)
        CFI (cfiCond66) DPH0 Frame(CFA_SP, 5)
        CFI (cfiCond66) CFA_SP SP+-5
        CFI Block cfiCond67 Using cfiCommon0
        CFI (cfiCond67) NoFunction
        CFI (cfiCond67) Conditional ??CrossCallReturnLabel_38
        CFI (cfiCond67) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond67) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond67) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond67) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond67) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond67) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond67) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond67) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond67) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond67) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond67) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond67) CFA_SP SP+0
        CFI (cfiCond67) CFA_XSP16 add(XSP16, 11)
        CFI Block cfiPicker68 Using cfiCommon1
        CFI (cfiPicker68) NoFunction
        CFI (cfiPicker68) Picker
        MOVX    A,@DPTR
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        MOV     R1,A
        MOV     A,R0
        ORL     A,R1
        RET
        CFI EndBlock cfiCond57
        CFI EndBlock cfiCond58
        CFI EndBlock cfiCond59
        CFI EndBlock cfiCond60
        CFI EndBlock cfiCond61
        CFI EndBlock cfiCond62
        CFI EndBlock cfiCond63
        CFI EndBlock cfiCond64
        CFI EndBlock cfiCond65
        CFI EndBlock cfiCond66
        CFI EndBlock cfiCond67
        CFI EndBlock cfiPicker68
//  547 
//  548 
//  549 
//  550 
//  551 /** \brief Processes the \ref GET_INTERFACE request (returns the selected alternate setting for the
//  552  * specified interface)
//  553  *
//  554  * Some USB devices have configurations with mutually exclusive interface settings. This request allows
//  555  * the host to determine the currently selected alternate setting.
//  556  *
//  557  * <b>Parameters</b>:
//  558  * - VALUE: Always 0
//  559  * - INDEX: Interface number
//  560  * - LENGTH: Always 1
//  561  *
//  562  * <b>Data (IN)</b>:
//  563  * The alternate setting for the selected interface
//  564  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  565 void usbsrGetInterface(void)
usbsrGetInterface:
        CFI Block cfiBlock69 Using cfiCommon0
        CFI Function usbsrGetInterface
        CODE
//  566 {
        MOV     A,#-0xb
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 11)
        ; Saved register size: 11
        ; Auto size: 0
//  567 
//  568    // Sanity check
//  569    if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_IN_INTERFACE) || usbSetupHeader.value || (usbSetupHeader.length != 1)) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrGetInterface_0
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        XRL     A,#0x81
        JNZ     ??usbsrGetInterface_0
        LCALL   ?Subroutine3 & 0xFFFF
??CrossCallReturnLabel_38:
        JNZ     ??usbsrGetInterface_0
        MOV     DPTR,#usbSetupHeader + 6
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrGetInterface_1
        INC     DPTR
        MOVX    A,@DPTR
??usbsrGetInterface_1:
        JZ      ??usbsrGetInterface_2
//  570       usbfwData.ep0Status = EP_STALL;
??usbsrGetInterface_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        SJMP    ??CrossCallReturnLabel_13
//  571 
//  572    // Return the current alternate setting
//  573    } else {
//  574       usbSetupData.pBuffer = &usbfwData.pAlternateSetting[usbSetupHeader.index];
??usbsrGetInterface_2:
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ADD     A,#(usbfwData + 2) & 0xff
        MOV     ?V0 + 0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     ?V0 + 1,A
        MOV     DPTR,#usbSetupData
        MOV     A,?V0 + 0
        MOVX    @DPTR,A
        INC     DPTR
        MOV     A,?V0 + 1
        LCALL   ?Subroutine9 & 0xFFFF
//  575       usbSetupData.bytesLeft = 1;
//  576       usbfwData.ep0Status = EP_TX;
//  577    }
??CrossCallReturnLabel_13:
        MOVX    @DPTR,A
//  578 
//  579 } // usbsrGetInterface
        SJMP    ?Subroutine2
        CFI EndBlock cfiBlock69

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine9:
        CFI Block cfiCond70 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_12
        CFI DPL0 Frame(CFA_SP, 4)
        CFI DPH0 Frame(CFA_SP, 5)
        CFI CFA_SP SP+-5
        CFI Block cfiCond71 Using cfiCommon0
        CFI (cfiCond71) NoFunction
        CFI (cfiCond71) Conditional ??CrossCallReturnLabel_13
        CFI (cfiCond71) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond71) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond71) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond71) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond71) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond71) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond71) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond71) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond71) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond71) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond71) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond71) CFA_SP SP+0
        CFI (cfiCond71) CFA_XSP16 add(XSP16, 11)
        CFI Block cfiPicker72 Using cfiCommon1
        CFI (cfiPicker72) NoFunction
        CFI (cfiPicker72) Picker
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        INC     DPTR
        INC     A
        LCALL   ?Subroutine15 & 0xFFFF
??CrossCallReturnLabel_25:
        RET
        CFI EndBlock cfiCond70
        CFI EndBlock cfiCond71
        CFI EndBlock cfiPicker72

        RSEG BANKED_CODE:CODE:NOROOT(0)
?Subroutine15:
        CFI Block cfiCond73 Using cfiCommon0
        CFI NoFunction
        CFI Conditional ??CrossCallReturnLabel_24
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        CFI Block cfiCond74 Using cfiCommon0
        CFI (cfiCond74) NoFunction
        CFI (cfiCond74) Conditional ??CrossCallReturnLabel_25, ??CrossCallReturnLabel_12
        CFI (cfiCond74) DPL0 Frame(CFA_SP, 4)
        CFI (cfiCond74) DPH0 Frame(CFA_SP, 5)
        CFI (cfiCond74) CFA_SP SP+-5
        CFI Block cfiCond75 Using cfiCommon0
        CFI (cfiCond75) NoFunction
        CFI (cfiCond75) Conditional ??CrossCallReturnLabel_25, ??CrossCallReturnLabel_13
        CFI (cfiCond75) R6 load(1, XDATA, add(CFA_XSP16, literal(-11)))
        CFI (cfiCond75) VB load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI (cfiCond75) V0 load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI (cfiCond75) V1 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI (cfiCond75) V2 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI (cfiCond75) R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI (cfiCond75) ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI (cfiCond75) ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI (cfiCond75) ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI (cfiCond75) DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI (cfiCond75) DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI (cfiCond75) CFA_SP SP+0
        CFI (cfiCond75) CFA_XSP16 add(XSP16, 11)
        CFI Block cfiPicker76 Using cfiCommon1
        CFI (cfiPicker76) NoFunction
        CFI (cfiPicker76) Picker
        MOVX    @DPTR,A
        INC     DPTR
        CLR     A
        MOVX    @DPTR,A
        MOV     DPTR,#usbfwData + 7
        INC     A
        RET
        CFI EndBlock cfiCond73
        CFI EndBlock cfiCond74
        CFI EndBlock cfiCond75
        CFI EndBlock cfiPicker76
//  580 
//  581 
//  582 
//  583 
//  584 /** \brief Processes the \ref SET_INTERFACE request (selects an alternate setting for the specified
//  585  * interface)
//  586  *
//  587  * Some USB devices have configurations with mutually exclusive interface settings. This request allows
//  588  * the host to select the desired alternate setting.
//  589  *
//  590  * This function uses the \c ConfigureEndpoints() to automatically setup the relevant endpoint
//  591  * registers.
//  592  *
//  593  * <b>Parameters</b>:
//  594  * - VALUE: Alternate setting
//  595  * - INDEX: Interface number
//  596  * - LENGTH: Always 0
//  597  */

        RSEG BANKED_CODE:CODE:NOROOT(0)
//  598 void usbsrSetInterface(void)
usbsrSetInterface:
        CFI Block cfiBlock77 Using cfiCommon0
        CFI Function usbsrSetInterface
        CODE
//  599 {
        FUNCALL usbsrSetInterface, usbdpGetInterfaceDesc
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, ConfigureEndpoints
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        FUNCALL usbsrSetInterface, usbsrHookProcessEvent
        LOCFRAME ISTACK, 0, STACK
        LOCFRAME PSTACK, 0, STACK
        LOCFRAME XSTACK, 10, STACK
        LOCFRAME IOVERLAY, 0, STATIC
        LOCFRAME DOVERLAY, 0, STATIC
        ARGFRAME ISTACK, 0, STACK
        ARGFRAME PSTACK, 0, STACK
        ARGFRAME XSTACK, 10, STACK
        ARGFRAME IOVERLAY, 0, STATIC
        ARGFRAME DOVERLAY, 0, STATIC
        MOV     A,#-0xa
        LCALL   ?BANKED_ENTER_XDATA
        CFI DPH0 load(1, XDATA, add(CFA_XSP16, literal(-1)))
        CFI DPL0 load(1, XDATA, add(CFA_XSP16, literal(-2)))
        CFI ?BRET_EXT load(1, XDATA, add(CFA_XSP16, literal(-3)))
        CFI ?RET_HIGH load(1, XDATA, add(CFA_XSP16, literal(-4)))
        CFI ?RET_LOW load(1, XDATA, add(CFA_XSP16, literal(-5)))
        CFI R7 load(1, XDATA, add(CFA_XSP16, literal(-6)))
        CFI V1 load(1, XDATA, add(CFA_XSP16, literal(-7)))
        CFI V0 load(1, XDATA, add(CFA_XSP16, literal(-8)))
        CFI VB load(1, XDATA, add(CFA_XSP16, literal(-9)))
        CFI R6 load(1, XDATA, add(CFA_XSP16, literal(-10)))
        CFI CFA_SP SP+0
        CFI CFA_XSP16 add(XSP16, 10)
        ; Saved register size: 10
        ; Auto size: 0
//  600    USB_INTERFACE_DESCRIPTOR __code *pInterface;
//  601 
//  602    // Sanity check
//  603    if ((usbfwData.usbState != DEV_CONFIGURED) || (usbSetupHeader.requestType != RT_OUT_INTERFACE) || usbSetupHeader.length) {
        MOV     DPTR,#usbfwData
        MOVX    A,@DPTR
        XRL     A,#0x4
        JNZ     ??usbsrSetInterface_0
        MOV     DPTR,#usbSetupHeader
        MOVX    A,@DPTR
        XRL     A,#0x1
        JNZ     ??usbsrSetInterface_0
        MOV     DPTR,#usbSetupHeader + 6
        LCALL   ??Subroutine17_0 & 0xFFFF
??CrossCallReturnLabel_35:
        JZ      ??usbsrSetInterface_1
//  604       usbfwData.ep0Status = EP_STALL;
??usbsrSetInterface_0:
        MOV     DPTR,#usbfwData + 7
        MOV     A,#0x4
        MOVX    @DPTR,A
        SJMP    ??usbsrSetInterface_2
//  605 
//  606    // Verify that the desired alternate setting is available, and then make the switch
//  607    } else {
//  608       if (pInterface = usbdpGetInterfaceDesc(usbfwData.configurationValue, usbSetupHeader.index, usbSetupHeader.value)) {
??usbsrSetInterface_1:
        ; Setup parameters for call to function usbdpGetInterfaceDesc
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        MOV     R3,A
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     DPTR,#usbfwData + 1
        MOVX    A,@DPTR
        MOV     R1,A
        LCALL   ??usbdpGetInterfaceDesc?relay
        MOV     ?V0 + 0,R2
        MOV     ?V0 + 1,R3
        MOV     R6,?V0 + 0
        MOV     R7,?V0 + 1
        MOV     A,R6
        ORL     A,R7
        JZ      ??usbsrSetInterface_0
//  609          usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGING, usbSetupHeader.index);
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R1,#0x3
        LCALL   ??usbsrHookProcessEvent?relay
//  610          usbfwData.pAlternateSetting[usbSetupHeader.index] = usbSetupHeader.value;
        MOV     DPTR,#usbSetupHeader + 2
        MOVX    A,@DPTR
        PUSH    A
        CFI CFA_SP SP+-1
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        ADD     A,#(usbfwData + 2) & 0xff
        MOV     R0,A
        INC     DPTR
        MOVX    A,@DPTR
        ADDC    A,#((usbfwData + 2) >> 8) & 0xff
        MOV     R1,A
        MOV     DPL,R0
        MOV     DPH,R1
        POP     A
        CFI CFA_SP SP+0
        MOVX    @DPTR,A
//  611 
//  612          // Configure all endpoints in this interface
//  613          ConfigureEndpoints(pInterface);
        ; Setup parameters for call to function ConfigureEndpoints
        MOV     A,R6
        MOV     R2,A
        MOV     A,R7
        MOV     R3,A
        LCALL   ??ConfigureEndpoints?relay
//  614          usbsrHookProcessEvent(USBSR_EVENT_INTERFACE_CHANGED, usbSetupHeader.index);
        ; Setup parameters for call to function usbsrHookProcessEvent
        MOV     DPTR,#usbSetupHeader + 4
        MOVX    A,@DPTR
        MOV     R2,A
        MOV     R1,#0x4
        LCALL   ??usbsrHookProcessEvent?relay
//  615 
//  616       // This interface does not exist
//  617       } else {
//  618          usbfwData.ep0Status = EP_STALL;
//  619       }
//  620    }
//  621 
//  622 } // usbsrSetInterface
??usbsrSetInterface_2:
        LJMP    ?Subroutine0 & 0xFFFF
        CFI EndBlock cfiBlock77

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetStatus?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrGetStatus

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ChangeFeature?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    ChangeFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrClearFeature?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrClearFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetFeature?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrSetFeature

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetAddress?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrSetAddress

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetDescriptor?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrGetDescriptor

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??ConfigureEndpoints?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    ConfigureEndpoints

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetConfiguration?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrGetConfiguration

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetConfiguration?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrSetConfiguration

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrGetInterface?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrGetInterface

        RSEG BANK_RELAYS:CODE:REORDER:NOROOT(0)
??usbsrSetInterface?relay:
        LCALL   ?BDISPATCH
        DATA
        DC24    usbsrSetInterface

        END
//  623 
//  624 //@}
//  625 
//  626 /*
//  627 +------------------------------------------------------------------------------
//  628 |  Copyright 2004-2010 Texas Instruments Incorporated. All rights reserved.
//  629 |
//  630 |  IMPORTANT: Your use of this Software is limited to those specific rights
//  631 |  granted under the terms of a software license agreement between the user who
//  632 |  downloaded the software, his/her employer (which must be your employer) and
//  633 |  Texas Instruments Incorporated (the "License"). You may not use this Software
//  634 |  unless you agree to abide by the terms of the License. The License limits
//  635 |  your use, and you acknowledge, that the Software may not be modified, copied
//  636 |  or distributed unless embedded on a Texas Instruments microcontroller or used
//  637 |  solely and exclusively in conjunction with a Texas Instruments radio
//  638 |  frequency transceiver, which is integrated into your product. Other than for
//  639 |  the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//  640 |  works of, modify, distribute, perform, display or sell this Software and/or
//  641 |  its documentation for any purpose.
//  642 |
//  643 |  YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//  644 |  PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//  645 |  INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//  646 |  NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//  647 |  TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//  648 |  NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//  649 |  LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING
//  650 |  BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR
//  651 |  CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
//  652 |  SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//  653 |  (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//  654 |
//  655 |  Should you have any questions regarding your right to use this Software,
//  656 |  contact Texas Instruments Incorporated at www.TI.com.
//  657 |
//  658 +------------------------------------------------------------------------------
//  659 */
// 
// 1 866 bytes in segment BANKED_CODE
//    66 bytes in segment BANK_RELAYS
//     2 bytes in segment XDATA_Z
// 
// 1 932 bytes of CODE  memory
//     2 bytes of XDATA memory
//
//Errors: none
//Warnings: none
